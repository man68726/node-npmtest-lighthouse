<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/base/multi_dimensional_view.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-lighthouse">npmtest-lighthouse (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/base/multi_dimensional_view.js</span></h1>
    <h2>
        
        Statements: <span class="metric">6.91% <small>(17 / 246)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0% <small>(0 / 67)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">3.85% <small>(1 / 26)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(1 / 1)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/base/</a> &#187; multi_dimensional_view.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2</td><td class="line-coverage"><span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";require("./base.js");'use strict';global.tr.exportTo('tr.b',function(){<span class="fstat-no" title="function not covered" >function MultiDimensionalViewNode(title,valueCount){<span class="cstat-no" title="statement not covered" ></span>this.title=title;<span class="cstat-no" title="statement not covered" >v</span>ar dimensions=title.length;<span class="cstat-no" title="statement not covered" >t</span>his.children=new Array(dimensions);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;dimensions;i++)<span class="cstat-no" title="statement not covered" >this.children[i]=new Map();<span class="cstat-no" title="statement not covered" >t</span></span>his.values=new Array(valueCount);<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;valueCount;v++)<span class="cstat-no" title="statement not covered" >this.values[v]={self:0,total:0,totalState:NOT_PROVIDED};}</span></span>MultiDimensionalViewNode.TotalState={NOT_PROVIDED:0,LOWER_BOUND:1,EXACT:2};var NOT_PROVIDED=MultiDimensionalViewNode.TotalState.NOT_PROVIDED;var LOWER_BOUND=MultiDimensionalViewNode.TotalState.LOWER_BOUND;var EXACT=MultiDimensionalViewNode.TotalState.EXACT;MultiDimensionalViewNode.prototype={get subRows<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return tr.b.mapValues(this.children[0]);}</span>};<span class="fstat-no" title="function not covered" >function MultiDimensionalViewBuilder(dimensions,valueCount){<span class="cstat-no" title="statement not covered" ></span>if(typeof dimensions!=='number'||dimensions&lt;0)<span class="cstat-no" title="statement not covered" >throw new Error('Dimensions must be a non-negative number');<span class="cstat-no" title="statement not covered" >t</span></span>his.dimensions_=dimensions;<span class="cstat-no" title="statement not covered" >i</span>f(typeof valueCount!=='number'||valueCount&lt;0)<span class="cstat-no" title="statement not covered" >throw new Error('Number of values must be a non-negative number');<span class="cstat-no" title="statement not covered" >t</span></span>his.valueCount_=valueCount;<span class="cstat-no" title="statement not covered" >t</span>his.buildRoot_=this.createRootNode_();<span class="cstat-no" title="statement not covered" >t</span>his.topDownTreeViewRoot_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.topDownHeavyViewRoot_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.bottomUpHeavyViewNode_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.maxDimensionDepths_=new Array(dimensions);<span class="cstat-no" title="statement not covered" >f</span>or(var d=0;d&lt;dimensions;d++)<span class="cstat-no" title="statement not covered" >this.maxDimensionDepths_[d]=0;}</span></span>MultiDimensionalViewBuilder.ValueKind={SELF:0,TOTAL:1};MultiDimensionalViewBuilder.ViewType={TOP_DOWN_TREE_VIEW:0,TOP_DOWN_HEAVY_VIEW:1,BOTTOM_UP_HEAVY_VIEW:2};MultiDimensionalViewBuilder.prototype={addPath:<span class="fstat-no" title="function not covered" >function(path,values,valueKind){<span class="cstat-no" title="statement not covered" ></span>if(this.buildRoot_===undefined){<span class="cstat-no" title="statement not covered" >throw new Error('Paths cannot be added after either view has been built');}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.length!==this.dimensions_)<span class="cstat-no" title="statement not covered" >throw new Error('Path must be '+this.dimensions_+'-dimensional');<span class="cstat-no" title="statement not covered" >i</span></span>f(values.length!==this.valueCount_)<span class="cstat-no" title="statement not covered" >throw new Error('Must provide '+this.valueCount_+' values');<span class="cstat-no" title="statement not covered" >v</span></span>ar isTotal;<span class="cstat-no" title="statement not covered" >s</span>witch(valueKind){case MultiDimensionalViewBuilder.ValueKind.SELF:<span class="cstat-no" title="statement not covered" >isTotal=false;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase MultiDimensionalViewBuilder.ValueKind.TOTAL:<span class="cstat-no" title="statement not covered" >isTotal=true;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error('Invalid value kind: '+valueKind);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=this.buildRoot_;<span class="cstat-no" title="statement not covered" >f</span>or(var d=0;d&lt;path.length;d++){<span class="cstat-no" title="statement not covered" >var singleDimensionPath=path[d];<span class="cstat-no" title="statement not covered" >v</span>ar singleDimensionPathLength=singleDimensionPath.length;<span class="cstat-no" title="statement not covered" >t</span>his.maxDimensionDepths_[d]=Math.max(this.maxDimensionDepths_[d],singleDimensionPathLength);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;singleDimensionPathLength;i++)<span class="cstat-no" title="statement not covered" >node=this.getOrCreateChildNode_(node,d,singleDimensionPath[i]);}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var v=0;v&lt;this.valueCount_;v++){<span class="cstat-no" title="statement not covered" >var addedValue=values[v];<span class="cstat-no" title="statement not covered" >i</span>f(addedValue===undefined)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar nodeValue=node.values[v];<span class="cstat-no" title="statement not covered" >i</span>f(isTotal){<span class="cstat-no" title="statement not covered" >nodeValue.total+=addedValue;<span class="cstat-no" title="statement not covered" >n</span>odeValue.totalState=EXACT;}</span>else{<span class="cstat-no" title="statement not covered" >nodeValue.self+=addedValue;<span class="cstat-no" title="statement not covered" >n</span>odeValue.totalState=Math.max(nodeValue.totalState,LOWER_BOUND);}</span>}</span>}</span>,buildView:<span class="fstat-no" title="function not covered" >function(viewType){<span class="cstat-no" title="statement not covered" ></span>switch(viewType){case MultiDimensionalViewBuilder.ViewType.TOP_DOWN_TREE_VIEW:<span class="cstat-no" title="statement not covered" >return this.buildTopDownTreeView();c</span>ase MultiDimensionalViewBuilder.ViewType.TOP_DOWN_HEAVY_VIEW:<span class="cstat-no" title="statement not covered" >return this.buildTopDownHeavyView();c</span>ase MultiDimensionalViewBuilder.ViewType.BOTTOM_UP_HEAVY_VIEW:<span class="cstat-no" title="statement not covered" >return this.buildBottomUpHeavyView();d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error('Unknown multi-dimensional view type: '+viewType);}</span>}</span>,buildTopDownTreeView:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.topDownTreeViewRoot_===undefined){<span class="cstat-no" title="statement not covered" >var treeViewRoot=this.buildRoot_;<span class="cstat-no" title="statement not covered" >t</span>his.buildRoot_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.setUpMissingChildRelationships_(treeViewRoot,0);<span class="cstat-no" title="statement not covered" >t</span>his.finalizeTotalValues_(treeViewRoot,0,new WeakMap());<span class="cstat-no" title="statement not covered" >t</span>his.topDownTreeViewRoot_=treeViewRoot;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.topDownTreeViewRoot_;}</span>,buildTopDownHeavyView:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.topDownHeavyViewRoot_===undefined){<span class="cstat-no" title="statement not covered" >this.topDownHeavyViewRoot_=this.buildGenericHeavyView_(this.addDimensionToTopDownHeavyViewNode_.bind(this));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.topDownHeavyViewRoot_;}</span>,buildBottomUpHeavyView:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.bottomUpHeavyViewNode_===undefined){<span class="cstat-no" title="statement not covered" >this.bottomUpHeavyViewNode_=this.buildGenericHeavyView_(this.addDimensionToBottomUpHeavyViewNode_.bind(this));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.bottomUpHeavyViewNode_;}</span>,createRootNode_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return new MultiDimensionalViewNode(new Array(this.dimensions_),this.valueCount_);}</span>,getOrCreateChildNode_:<span class="fstat-no" title="function not covered" >function(parentNode,dimension,childDimensionTitle){<span class="cstat-no" title="statement not covered" ></span>if(dimension&lt;0||dimension&gt;=this.dimensions_)<span class="cstat-no" title="statement not covered" >throw new Error('Invalid dimension');<span class="cstat-no" title="statement not covered" >v</span></span>ar dimensionChildren=parentNode.children[dimension];<span class="cstat-no" title="statement not covered" >v</span>ar childNode=dimensionChildren.get(childDimensionTitle);<span class="cstat-no" title="statement not covered" >i</span>f(childNode!==undefined)<span class="cstat-no" title="statement not covered" >return childNode;<span class="cstat-no" title="statement not covered" >v</span></span>ar childTitle=parentNode.title.slice();<span class="cstat-no" title="statement not covered" >c</span>hildTitle[dimension]=childDimensionTitle;<span class="cstat-no" title="statement not covered" >c</span>hildNode=new MultiDimensionalViewNode(childTitle,this.valueCount_);<span class="cstat-no" title="statement not covered" >d</span>imensionChildren.set(childDimensionTitle,childNode);<span class="cstat-no" title="statement not covered" >r</span>eturn childNode;}</span>,setUpMissingChildRelationships_:<span class="fstat-no" title="function not covered" >function(node,firstDimensionToSetUp){<span class="cstat-no" title="statement not covered" ></span>for(var d=firstDimensionToSetUp;d&lt;this.dimensions_;d++){<span class="cstat-no" title="statement not covered" >var currentDimensionChildTitles=new Set(node.children[d].keys());<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;d;i++){<span class="cstat-no" title="statement not covered" >for(var previousDimensionChildNode of node.children[i].values()){<span class="cstat-no" title="statement not covered" >for(var previousDimensionGrandChildTitle of previousDimensionChildNode.children[d].keys()){<span class="cstat-no" title="statement not covered" >currentDimensionChildTitles.add(previousDimensionGrandChildTitle);}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var currentDimensionChildTitle of currentDimensionChildTitles){<span class="cstat-no" title="statement not covered" >var currentDimensionChildNode=this.getOrCreateChildNode_(node,d,currentDimensionChildTitle);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;d;i++){<span class="cstat-no" title="statement not covered" >for(var previousDimensionChildNode of node.children[i].values()){<span class="cstat-no" title="statement not covered" >var previousDimensionGrandChildNode=previousDimensionChildNode.children[d].get(currentDimensionChildTitle);<span class="cstat-no" title="statement not covered" >i</span>f(previousDimensionGrandChildNode!==undefined){<span class="cstat-no" title="statement not covered" >currentDimensionChildNode.children[i].set(previousDimensionChildNode.title[i],previousDimensionGrandChildNode);}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.setUpMissingChildRelationships_(currentDimensionChildNode,d);}</span>}</span>}</span>,finalizeTotalValues_:<span class="fstat-no" title="function not covered" >function(node,firstDimensionToFinalize,dimensionalSelfSumsMap){<span class="cstat-no" title="statement not covered" ></span>var dimensionalSelfSums=new Array(this.dimensions_);<span class="cstat-no" title="statement not covered" >v</span>ar minResidual=new Array(this.valueCount_);<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;this.valueCount_;v++)<span class="cstat-no" title="statement not covered" >minResidual[v]=0;<span class="cstat-no" title="statement not covered" >v</span></span>ar nodeValues=node.values;<span class="cstat-no" title="statement not covered" >v</span>ar nodeSelfSums=new Array(this.valueCount_);<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;this.valueCount_;v++)<span class="cstat-no" title="statement not covered" >nodeSelfSums[v]=nodeValues[v].self;<span class="cstat-no" title="statement not covered" >f</span></span>or(var d=0;d&lt;this.dimensions_;d++){<span class="cstat-no" title="statement not covered" >var childResidualSums=new Array(this.valueCount_);<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;this.valueCount_;v++)<span class="cstat-no" title="statement not covered" >childResidualSums[v]=0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var childNode of node.children[d].values()){<span class="cstat-no" title="statement not covered" >if(d&gt;=firstDimensionToFinalize)<span class="cstat-no" title="statement not covered" >this.finalizeTotalValues_(childNode,d,dimensionalSelfSumsMap);<span class="cstat-no" title="statement not covered" >v</span></span>ar childNodeSelfSums=dimensionalSelfSumsMap.get(childNode);<span class="cstat-no" title="statement not covered" >v</span>ar childNodeValues=childNode.values;<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;this.valueCount_;v++){<span class="cstat-no" title="statement not covered" >nodeSelfSums[v]+=childNodeSelfSums[d][v];<span class="cstat-no" title="statement not covered" >v</span>ar residual=childNodeValues[v].total-childNodeSelfSums[this.dimensions_-1][v];<span class="cstat-no" title="statement not covered" >c</span>hildResidualSums[v]+=residual;<span class="cstat-no" title="statement not covered" >i</span>f(childNodeValues[v].totalState&gt;NOT_PROVIDED){<span class="cstat-no" title="statement not covered" >nodeValues[v].totalState=Math.max(nodeValues[v].totalState,LOWER_BOUND);}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>d</span>imensionalSelfSums[d]=nodeSelfSums.slice();<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;this.valueCount_;v++)<span class="cstat-no" title="statement not covered" >minResidual[v]=Math.max(minResidual[v],childResidualSums[v]);}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var v=0;v&lt;this.valueCount_;v++){<span class="cstat-no" title="statement not covered" >nodeValues[v].total=Math.max(nodeValues[v].total,nodeSelfSums[v]+minResidual[v]);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dimensionalSelfSumsMap.has(node))<span class="cstat-no" title="statement not covered" >throw new Error('Internal error: Node finalized more than once');<span class="cstat-no" title="statement not covered" >d</span></span>imensionalSelfSumsMap.set(node,dimensionalSelfSums);}</span>,buildGenericHeavyView_:<span class="fstat-no" title="function not covered" >function(treeViewNodeHandler){<span class="cstat-no" title="statement not covered" ></span>var treeViewRoot=this.buildTopDownTreeView();<span class="cstat-no" title="statement not covered" >v</span>ar heavyViewRoot=this.createRootNode_();<span class="cstat-no" title="statement not covered" >h</span>eavyViewRoot.values=treeViewRoot.values;<span class="cstat-no" title="statement not covered" >v</span>ar recursionDepthTrackers=new Array(this.dimensions_);<span class="cstat-no" title="statement not covered" >f</span>or(var d=0;d&lt;this.dimensions_;d++){<span class="cstat-no" title="statement not covered" >recursionDepthTrackers[d]=new RecursionDepthTracker(this.maxDimensionDepths_[d],d);}<span class="cstat-no" title="statement not covered" ></span>t</span>his.addDimensionsToGenericHeavyViewNode_(treeViewRoot,heavyViewRoot,0,recursionDepthTrackers,false,treeViewNodeHandler);<span class="cstat-no" title="statement not covered" >t</span>his.setUpMissingChildRelationships_(heavyViewRoot,0);<span class="cstat-no" title="statement not covered" >r</span>eturn heavyViewRoot;}</span>,addDimensionsToGenericHeavyViewNode_:<span class="fstat-no" title="function not covered" >function(treeViewParentNode,heavyViewParentNode,startDimension,recursionDepthTrackers,previousDimensionsRecursive,treeViewNodeHandler){<span class="cstat-no" title="statement not covered" ></span>for(var d=startDimension;d&lt;this.dimensions_;d++){<span class="cstat-no" title="statement not covered" >this.addDimensionDescendantsToGenericHeavyViewNode_(treeViewParentNode,heavyViewParentNode,d,recursionDepthTrackers,previousDimensionsRecursive,treeViewNodeHandler);}</span>}</span>,addDimensionDescendantsToGenericHeavyViewNode_:<span class="fstat-no" title="function not covered" >function(treeViewParentNode,heavyViewParentNode,currentDimension,recursionDepthTrackers,previousDimensionsRecursive,treeViewNodeHandler){<span class="cstat-no" title="statement not covered" ></span>var treeViewChildren=treeViewParentNode.children[currentDimension];<span class="cstat-no" title="statement not covered" >v</span>ar recursionDepthTracker=recursionDepthTrackers[currentDimension];<span class="cstat-no" title="statement not covered" >f</span>or(var treeViewChildNode of treeViewChildren.values()){<span class="cstat-no" title="statement not covered" >recursionDepthTracker.push(treeViewChildNode);<span class="cstat-no" title="statement not covered" >t</span>reeViewNodeHandler(treeViewChildNode,heavyViewParentNode,currentDimension,recursionDepthTrackers,previousDimensionsRecursive);<span class="cstat-no" title="statement not covered" >t</span>his.addDimensionDescendantsToGenericHeavyViewNode_(treeViewChildNode,heavyViewParentNode,currentDimension,recursionDepthTrackers,previousDimensionsRecursive,treeViewNodeHandler);<span class="cstat-no" title="statement not covered" >r</span>ecursionDepthTracker.pop();}</span>}</span>,addDimensionToTopDownHeavyViewNode_:<span class="fstat-no" title="function not covered" >function(treeViewChildNode,heavyViewParentNode,currentDimension,recursionDepthTrackers,previousDimensionsRecursive){<span class="cstat-no" title="statement not covered" ></span>this.addDimensionToTopDownHeavyViewNodeRecursively_(treeViewChildNode,heavyViewParentNode,currentDimension,recursionDepthTrackers,previousDimensionsRecursive,1);}</span>,addDimensionToTopDownHeavyViewNodeRecursively_:<span class="fstat-no" title="function not covered" >function(treeViewChildNode,heavyViewParentNode,currentDimension,recursionDepthTrackers,previousDimensionsRecursive,subTreeDepth){<span class="cstat-no" title="statement not covered" ></span>var recursionDepthTracker=recursionDepthTrackers[currentDimension];<span class="cstat-no" title="statement not covered" >v</span>ar currentDimensionRecursive=subTreeDepth&lt;=recursionDepthTracker.recursionDepth;<span class="cstat-no" title="statement not covered" >v</span>ar currentOrPreviousDimensionsRecursive=currentDimensionRecursive||previousDimensionsRecursive;<span class="cstat-no" title="statement not covered" >v</span>ar dimensionTitle=treeViewChildNode.title[currentDimension];<span class="cstat-no" title="statement not covered" >v</span>ar heavyViewChildNode=this.getOrCreateChildNode_(heavyViewParentNode,currentDimension,dimensionTitle);<span class="cstat-no" title="statement not covered" >t</span>his.addNodeValues_(treeViewChildNode,heavyViewChildNode,!currentOrPreviousDimensionsRecursive);<span class="cstat-no" title="statement not covered" >t</span>his.addDimensionsToGenericHeavyViewNode_(treeViewChildNode,heavyViewChildNode,currentDimension+1,recursionDepthTrackers,currentOrPreviousDimensionsRecursive,this.addDimensionToTopDownHeavyViewNode_.bind(this));<span class="cstat-no" title="statement not covered" >f</span>or(var treeViewGrandChildNode of treeViewChildNode.children[currentDimension].values()){<span class="cstat-no" title="statement not covered" >recursionDepthTracker.push(treeViewGrandChildNode);<span class="cstat-no" title="statement not covered" >t</span>his.addDimensionToTopDownHeavyViewNodeRecursively_(treeViewGrandChildNode,heavyViewChildNode,currentDimension,recursionDepthTrackers,previousDimensionsRecursive,subTreeDepth+1);<span class="cstat-no" title="statement not covered" >r</span>ecursionDepthTracker.pop();}</span>}</span>,addDimensionToBottomUpHeavyViewNode_:<span class="fstat-no" title="function not covered" >function(treeViewChildNode,heavyViewParentNode,currentDimension,recursionDepthTrackers,previousDimensionsRecursive){<span class="cstat-no" title="statement not covered" ></span>var recursionDepthTracker=recursionDepthTrackers[currentDimension];<span class="cstat-no" title="statement not covered" >v</span>ar bottomIndex=recursionDepthTracker.bottomIndex;<span class="cstat-no" title="statement not covered" >v</span>ar topIndex=recursionDepthTracker.topIndex;<span class="cstat-no" title="statement not covered" >v</span>ar firstNonRecursiveIndex=bottomIndex+recursionDepthTracker.recursionDepth;<span class="cstat-no" title="statement not covered" >v</span>ar viewNodePath=recursionDepthTracker.viewNodePath;<span class="cstat-no" title="statement not covered" >v</span>ar trackerAncestorNode=recursionDepthTracker.trackerAncestorNode;<span class="cstat-no" title="statement not covered" >v</span>ar heavyViewDescendantNode=heavyViewParentNode;<span class="cstat-no" title="statement not covered" >f</span>or(var i=bottomIndex;i&lt;topIndex;i++){<span class="cstat-no" title="statement not covered" >var treeViewAncestorNode=viewNodePath[i];<span class="cstat-no" title="statement not covered" >v</span>ar dimensionTitle=treeViewAncestorNode.title[currentDimension];<span class="cstat-no" title="statement not covered" >h</span>eavyViewDescendantNode=this.getOrCreateChildNode_(heavyViewDescendantNode,currentDimension,dimensionTitle);<span class="cstat-no" title="statement not covered" >v</span>ar currentDimensionRecursive=i&lt;firstNonRecursiveIndex;<span class="cstat-no" title="statement not covered" >v</span>ar currentOrPreviousDimensionsRecursive=currentDimensionRecursive||previousDimensionsRecursive;<span class="cstat-no" title="statement not covered" >t</span>his.addNodeValues_(treeViewChildNode,heavyViewDescendantNode,!currentOrPreviousDimensionsRecursive);<span class="cstat-no" title="statement not covered" >t</span>his.addDimensionsToGenericHeavyViewNode_(treeViewChildNode,heavyViewDescendantNode,currentDimension+1,recursionDepthTrackers,currentOrPreviousDimensionsRecursive,this.addDimensionToBottomUpHeavyViewNode_.bind(this));}</span>}</span>,addNodeValues_:<span class="fstat-no" title="function not covered" >function(sourceNode,targetNode,addTotal){<span class="cstat-no" title="statement not covered" ></span>var targetNodeValues=targetNode.values;<span class="cstat-no" title="statement not covered" >v</span>ar sourceNodeValues=sourceNode.values;<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;this.valueCount_;v++){<span class="cstat-no" title="statement not covered" >var targetNodeValue=targetNodeValues[v];<span class="cstat-no" title="statement not covered" >v</span>ar sourceNodeValue=sourceNodeValues[v];<span class="cstat-no" title="statement not covered" >t</span>argetNodeValue.self+=sourceNodeValue.self;<span class="cstat-no" title="statement not covered" >i</span>f(addTotal){<span class="cstat-no" title="statement not covered" >targetNodeValue.total+=sourceNodeValue.total;<span class="cstat-no" title="statement not covered" >i</span>f(sourceNodeValue.totalState&gt;NOT_PROVIDED){<span class="cstat-no" title="statement not covered" >targetNodeValue.totalState=Math.max(targetNodeValue.totalState,LOWER_BOUND);}</span>}</span>}</span>}</span>};<span class="fstat-no" title="function not covered" >function RecursionDepthTracker(maxDepth,dimension){<span class="cstat-no" title="statement not covered" ></span>this.titlePath=new Array(maxDepth);<span class="cstat-no" title="statement not covered" >t</span>his.viewNodePath=new Array(maxDepth);<span class="cstat-no" title="statement not covered" >t</span>his.bottomIndex=this.topIndex=maxDepth;<span class="cstat-no" title="statement not covered" >t</span>his.dimension_=dimension;<span class="cstat-no" title="statement not covered" >t</span>his.currentTrackerNode_=this.createNode_(0,undefined);}</span>RecursionDepthTracker.prototype={push:<span class="fstat-no" title="function not covered" >function(viewNode){<span class="cstat-no" title="statement not covered" ></span>if(this.bottomIndex===0)<span class="cstat-no" title="statement not covered" >throw new Error('Cannot push to a full tracker');<span class="cstat-no" title="statement not covered" >v</span></span>ar title=viewNode.title[this.dimension_];<span class="cstat-no" title="statement not covered" >t</span>his.bottomIndex--;<span class="cstat-no" title="statement not covered" >t</span>his.titlePath[this.bottomIndex]=title;<span class="cstat-no" title="statement not covered" >t</span>his.viewNodePath[this.bottomIndex]=viewNode;<span class="cstat-no" title="statement not covered" >v</span>ar childTrackerNode=this.currentTrackerNode_.children.get(title);<span class="cstat-no" title="statement not covered" >i</span>f(childTrackerNode!==undefined){<span class="cstat-no" title="statement not covered" >this.currentTrackerNode_=childTrackerNode;<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar maxLengths=zFunction(this.titlePath,this.bottomIndex);<span class="cstat-no" title="statement not covered" >v</span>ar recursionDepth=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;maxLengths.length;i++)<span class="cstat-no" title="statement not covered" >recursionDepth=Math.max(recursionDepth,maxLengths[i]);<span class="cstat-no" title="statement not covered" >c</span></span>hildTrackerNode=this.createNode_(recursionDepth,this.currentTrackerNode_);<span class="cstat-no" title="statement not covered" >t</span>his.currentTrackerNode_.children.set(title,childTrackerNode);<span class="cstat-no" title="statement not covered" >t</span>his.currentTrackerNode_=childTrackerNode;}</span>,pop:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.bottomIndex===this.topIndex)<span class="cstat-no" title="statement not covered" >throw new Error('Cannot pop from an empty tracker');<span class="cstat-no" title="statement not covered" >t</span></span>his.titlePath[this.bottomIndex]=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.viewNodePath[this.bottomIndex]=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.bottomIndex++;<span class="cstat-no" title="statement not covered" >t</span>his.currentTrackerNode_=this.currentTrackerNode_.parent;}</span>,get recursionDepth<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.currentTrackerNode_.recursionDepth;}</span>,createNode_:<span class="fstat-no" title="function not covered" >function(recursionDepth,parent){<span class="cstat-no" title="statement not covered" ></span>return{recursionDepth:recursionDepth,parent:parent,children:new Map()};}</span>};<span class="fstat-no" title="function not covered" >function zFunction(list,startIndex){<span class="cstat-no" title="statement not covered" ></span>var n=list.length-startIndex;<span class="cstat-no" title="statement not covered" >i</span>f(n===0)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >v</span></span>ar z=new Array(n);<span class="cstat-no" title="statement not covered" >z</span>[0]=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=1,left=0,right=0;i&lt;n;++i){<span class="cstat-no" title="statement not covered" >var maxLength;<span class="cstat-no" title="statement not covered" >i</span>f(i&lt;=right)<span class="cstat-no" title="statement not covered" >maxLength=Math.min(right-i+1,z[i-left]);e</span>lse <span class="cstat-no" title="statement not covered" >maxLength=0;<span class="cstat-no" title="statement not covered" >w</span></span>hile(i+maxLength&lt;n&amp;&amp;list[startIndex+maxLength]===list[startIndex+i+maxLength]){<span class="cstat-no" title="statement not covered" >++maxLength;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i+maxLength-1&gt;right){<span class="cstat-no" title="statement not covered" >left=i;<span class="cstat-no" title="statement not covered" >r</span>ight=i+maxLength-1;}<span class="cstat-no" title="statement not covered" ></span>z</span>[i]=maxLength;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn z;}</span>return{MultiDimensionalViewBuilder:MultiDimensionalViewBuilder,MultiDimensionalViewNode:MultiDimensionalViewNode,RecursionDepthTracker:RecursionDepthTracker,zFunction:zFunction};});
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 14:22:44 GMT+0000 (UTC)</div>
</div>
</body>
</html>
