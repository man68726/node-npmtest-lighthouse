<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/metrics/system_health/memory_metric.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-lighthouse">npmtest-lighthouse (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/metrics/system_health/memory_metric.js</span></h1>
    <h2>
        
        Statements: <span class="metric">17.59% <small>(57 / 324)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0% <small>(0 / 125)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">1.79% <small>(1 / 56)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(1 / 1)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/metrics/system_health/</a> &#187; memory_metric.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2</td><td class="line-coverage"><span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";require("../../base/iteration_helpers.js");require("../../base/multi_dimensional_view.js");require("../../base/range.js");require("../../base/unit.js");require("../metric_registry.js");require("../../model/container_memory_dump.js");require("../../model/helpers/chrome_model_helper.js");require("../../model/memory_allocator_dump.js");require("../../value/histogram.js");'use strict';global.tr.exportTo('tr.metrics.sh',function(){var BACKGROUND=tr.model.ContainerMemoryDump.LevelOfDetail.BACKGROUND;var LIGHT=tr.model.ContainerMemoryDump.LevelOfDetail.LIGHT;var DETAILED=tr.model.ContainerMemoryDump.LevelOfDetail.DETAILED;var sizeInBytes_smallerIsBetter=tr.b.Unit.byName.sizeInBytes_smallerIsBetter;var count_smallerIsBetter=tr.b.Unit.byName.count_smallerIsBetter;var DISPLAYED_SIZE_NUMERIC_NAME=tr.model.MemoryAllocatorDump.DISPLAYED_SIZE_NUMERIC_NAME;var LEVEL_OF_DETAIL_NAMES=new Map();LEVEL_OF_DETAIL_NAMES.set(BACKGROUND,'background');LEVEL_OF_DETAIL_NAMES.set(LIGHT,'light');LEVEL_OF_DETAIL_NAMES.set(DETAILED,'detailed');var BOUNDARIES_FOR_UNIT_MAP=new WeakMap();BOUNDARIES_FOR_UNIT_MAP.set(count_smallerIsBetter,tr.v.HistogramBinBoundaries.createLinear(0,20,20));BOUNDARIES_FOR_UNIT_MAP.set(sizeInBytes_smallerIsBetter,new tr.v.HistogramBinBoundaries(0).addBinBoundary(1024).addExponentialBins(16*1024*1024*1024,4*24));<span class="fstat-no" title="function not covered" >function memoryMetric(values,model,opt_options){<span class="cstat-no" title="statement not covered" ></span>var rangeOfInterest=opt_options?opt_options.rangeOfInterest:undefined;<span class="cstat-no" title="statement not covered" >v</span>ar browserNameToGlobalDumps=splitGlobalDumpsByBrowserName(model,rangeOfInterest);<span class="cstat-no" title="statement not covered" >a</span>ddGeneralMemoryDumpValues(browserNameToGlobalDumps,values);<span class="cstat-no" title="statement not covered" >a</span>ddDetailedMemoryDumpValues(browserNameToGlobalDumps,values);<span class="cstat-no" title="statement not covered" >a</span>ddMemoryDumpCountValues(browserNameToGlobalDumps,values);}<span class="fstat-no" title="function not covered" ></span>function splitGlobalDumpsByBrowserName(model,opt_rangeOfInterest){<span class="cstat-no" title="statement not covered" ></span>var chromeModelHelper=model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);<span class="cstat-no" title="statement not covered" >v</span>ar browserNameToGlobalDumps=new Map();<span class="cstat-no" title="statement not covered" >v</span>ar globalDumpToBrowserHelper=new WeakMap();<span class="cstat-no" title="statement not covered" >i</span>f(chromeModelHelper){<span class="cstat-no" title="statement not covered" >chromeModelHelper.browserHelpers.forEach(<span class="fstat-no" title="function not covered" >function(helper){<span class="cstat-no" title="statement not covered" ></span>var globalDumps=skipDumpsThatDoNotIntersectRange(helper.process.memoryDumps.map(d=&gt;<span class="cstat-no" title="statement not covered" >d.globalMemoryDump)</span>,opt_rangeOfInterest);<span class="cstat-no" title="statement not covered" >g</span>lobalDumps.forEach(<span class="fstat-no" title="function not covered" >function(globalDump){<span class="cstat-no" title="statement not covered" ></span>var existingHelper=globalDumpToBrowserHelper.get(globalDump);<span class="cstat-no" title="statement not covered" >i</span>f(existingHelper!==undefined){<span class="cstat-no" title="statement not covered" >throw new Error('Memory dump ID clash across multiple browsers '+'with PIDs: '+existingHelper.pid+' and '+helper.pid);}<span class="cstat-no" title="statement not covered" ></span>g</span>lobalDumpToBrowserHelper.set(globalDump,helper);}</span>);<span class="cstat-no" title="statement not covered" >m</span>akeKeyUniqueAndSet(browserNameToGlobalDumps,canonicalizeName(helper.browserName),globalDumps);}</span>);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar unclassifiedGlobalDumps=skipDumpsThatDoNotIntersectRange(model.globalMemoryDumps.filter(g=&gt;<span class="cstat-no" title="statement not covered" >!globalDumpToBrowserHelper.has(g))</span>,opt_rangeOfInterest);<span class="cstat-no" title="statement not covered" >i</span>f(unclassifiedGlobalDumps.length&gt;0){<span class="cstat-no" title="statement not covered" >makeKeyUniqueAndSet(browserNameToGlobalDumps,'unknown_browser',unclassifiedGlobalDumps);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn browserNameToGlobalDumps;}<span class="fstat-no" title="function not covered" ></span>function skipDumpsThatDoNotIntersectRange(dumps,opt_range){<span class="cstat-no" title="statement not covered" ></span>if(!opt_range)<span class="cstat-no" title="statement not covered" >return dumps;<span class="cstat-no" title="statement not covered" >r</span></span>eturn dumps.filter(d=&gt;<span class="cstat-no" title="statement not covered" >opt_range.intersectsExplicitRangeInclusive(d.start,d.end))</span>;}<span class="fstat-no" title="function not covered" ></span>function canonicalizeName(name){<span class="cstat-no" title="statement not covered" ></span>return name.toLowerCase().replace(' ','_');}</span>var USER_FRIENDLY_BROWSER_NAMES={'chrome':'Chrome','webview':'WebView','unknown_browser':'an unknown browser'};<span class="fstat-no" title="function not covered" >function convertBrowserNameToUserFriendlyName(browserName){<span class="cstat-no" title="statement not covered" ></span>for(var baseName in USER_FRIENDLY_BROWSER_NAMES){<span class="cstat-no" title="statement not covered" >if(!browserName.startsWith(baseName))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar userFriendlyBaseName=USER_FRIENDLY_BROWSER_NAMES[baseName];<span class="cstat-no" title="statement not covered" >v</span>ar suffix=browserName.substring(baseName.length);<span class="cstat-no" title="statement not covered" >i</span>f(suffix.length===0)<span class="cstat-no" title="statement not covered" >return userFriendlyBaseName;e</span>lse <span class="cstat-no" title="statement not covered" >if(/^\d+$/.test(suffix))<span class="cstat-no" title="statement not covered" >return userFriendlyBaseName+'('+suffix+')';}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn'\''+browserName+'\' browser';}<span class="fstat-no" title="function not covered" ></span>function canonicalizeProcessName(rawProcessName){<span class="cstat-no" title="statement not covered" ></span>if(!rawProcessName)<span class="cstat-no" title="statement not covered" >return'unknown_processes';<span class="cstat-no" title="statement not covered" >v</span></span>ar baseCanonicalName=canonicalizeName(rawProcessName);<span class="cstat-no" title="statement not covered" >s</span>witch(baseCanonicalName){case'renderer':<span class="cstat-no" title="statement not covered" >return'renderer_processes';c</span>ase'browser':<span class="cstat-no" title="statement not covered" >return'browser_process';d</span>efault:<span class="cstat-no" title="statement not covered" >return baseCanonicalName;}</span>}<span class="fstat-no" title="function not covered" ></span>function convertProcessNameToUserFriendlyName(processName,opt_requirePlural){<span class="cstat-no" title="statement not covered" ></span>switch(processName){case'browser_process':<span class="cstat-no" title="statement not covered" >return opt_requirePlural?'browser processes':'the browser process';c</span>ase'renderer_processes':<span class="cstat-no" title="statement not covered" >return'renderer processes';c</span>ase'gpu_process':<span class="cstat-no" title="statement not covered" >return opt_requirePlural?'GPU processes':'the GPU process';c</span>ase'ppapi_process':<span class="cstat-no" title="statement not covered" >return opt_requirePlural?'PPAPI processes':'the PPAPI process';c</span>ase'all_processes':<span class="cstat-no" title="statement not covered" >return'all processes';c</span>ase'unknown_processes':<span class="cstat-no" title="statement not covered" >return'unknown processes';d</span>efault:<span class="cstat-no" title="statement not covered" >return'\''+processName+'\' processes';}</span>}<span class="fstat-no" title="function not covered" ></span>function makeKeyUniqueAndSet(map,key,value){<span class="cstat-no" title="statement not covered" ></span>var uniqueKey=key;<span class="cstat-no" title="statement not covered" >v</span>ar nextIndex=2;<span class="cstat-no" title="statement not covered" >w</span>hile(map.has(uniqueKey)){<span class="cstat-no" title="statement not covered" >uniqueKey=key+nextIndex;<span class="cstat-no" title="statement not covered" >n</span>extIndex++;}<span class="cstat-no" title="statement not covered" ></span>m</span>ap.set(uniqueKey,value);}<span class="fstat-no" title="function not covered" ></span>function addGeneralMemoryDumpValues(browserNameToGlobalDumps,values){<span class="cstat-no" title="statement not covered" ></span>addMemoryDumpValues(browserNameToGlobalDumps,gmd=&gt;<span class="cstat-no" title="statement not covered" >true,<span class="fstat-no" title="function not covered" ></span>function(processDump,addProcessScalar){<span class="cstat-no" title="statement not covered" ></span>addProcessScalar({source:'process_count',value:1,unit:count_smallerIsBetter,descriptionPrefixBuilder:buildProcessCountDescriptionPrefix});<span class="cstat-no" title="statement not covered" >i</span>f(processDump.totals!==undefined){<span class="cstat-no" title="statement not covered" >tr.b.iterItems(SYSTEM_TOTAL_VALUE_PROPERTIES,<span class="fstat-no" title="function not covered" >function(propertyName,propertySpec){<span class="cstat-no" title="statement not covered" ></span>addProcessScalar({source:'reported_by_os',property:propertyName,component:['system_memory'],value:propertySpec.getPropertyFunction(processDump),unit:sizeInBytes_smallerIsBetter,descriptionPrefixBuilder:propertySpec.descriptionPrefixBuilder});}</span>);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(processDump.memoryAllocatorDumps===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >p</span></span>rocessDump.memoryAllocatorDumps.forEach(<span class="fstat-no" title="function not covered" >function(rootAllocatorDump){<span class="cstat-no" title="statement not covered" ></span>tr.b.iterItems(CHROME_VALUE_PROPERTIES,<span class="fstat-no" title="function not covered" >function(propertyName,descriptionPrefixBuilder){<span class="cstat-no" title="statement not covered" ></span>addProcessScalar({source:'reported_by_chrome',component:[rootAllocatorDump.name],property:propertyName,value:rootAllocatorDump.numerics[propertyName],descriptionPrefixBuilder:descriptionPrefixBuilder});}</span>);<span class="cstat-no" title="statement not covered" >i</span>f(rootAllocatorDump.numerics['allocated_objects_size']===undefined){<span class="cstat-no" title="statement not covered" >var allocatedObjectsDump=rootAllocatorDump.getDescendantDumpByFullName('allocated_objects');<span class="cstat-no" title="statement not covered" >i</span>f(allocatedObjectsDump!==undefined){<span class="cstat-no" title="statement not covered" >addProcessScalar({source:'reported_by_chrome',component:[rootAllocatorDump.name],property:'allocated_objects_size',value:allocatedObjectsDump.numerics['size'],descriptionPrefixBuilder:CHROME_VALUE_PROPERTIES['allocated_objects_size']});}</span>}</span>}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddV8MemoryDumpValues(processDump,addProcessScalar);}</span>,<span class="fstat-no" title="function not covered" >function(componentTree){<span class="cstat-no" title="statement not covered" ></span>var tracingNode=componentTree.children[1].get('tracing');<span class="cstat-no" title="statement not covered" >i</span>f(tracingNode===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=0;i&lt;componentTree.values.length;i++)<span class="cstat-no" title="statement not covered" >componentTree.values[i].total-=tracingNode.values[i].total;}</span></span>,values);}<span class="fstat-no" title="function not covered" ></span>function addV8MemoryDumpValues(processDump,addProcessScalar){<span class="cstat-no" title="statement not covered" ></span>var v8Dump=processDump.getMemoryAllocatorDumpByFullName('v8');<span class="cstat-no" title="statement not covered" >i</span>f(v8Dump===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>8Dump.children.forEach(<span class="fstat-no" title="function not covered" >function(isolateDump){<span class="cstat-no" title="statement not covered" ></span>var mallocDump=isolateDump.getDescendantDumpByFullName('malloc');<span class="cstat-no" title="statement not covered" >i</span>f(mallocDump!==undefined){<span class="cstat-no" title="statement not covered" >addV8ComponentValues(mallocDump,['v8','allocated_by_malloc'],addProcessScalar);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar heapDump=isolateDump.getDescendantDumpByFullName('heap_spaces');<span class="cstat-no" title="statement not covered" >i</span>f(heapDump!==undefined){<span class="cstat-no" title="statement not covered" >addV8ComponentValues(heapDump,['v8','heap'],addProcessScalar);<span class="cstat-no" title="statement not covered" >h</span>eapDump.children.forEach(<span class="fstat-no" title="function not covered" >function(spaceDump){<span class="cstat-no" title="statement not covered" ></span>if(spaceDump.name==='other_spaces')<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >a</span></span>ddV8ComponentValues(spaceDump,['v8','heap',spaceDump.name],addProcessScalar);}</span>);}</span>}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddProcessScalar({source:'reported_by_chrome',component:['v8'],property:'code_and_metadata_size',value:v8Dump.numerics['code_and_metadata_size'],descriptionPrefixBuilder:buildCodeAndMetadataSizeValueDescriptionPrefix});<span class="cstat-no" title="statement not covered" >a</span>ddProcessScalar({source:'reported_by_chrome',component:['v8'],property:'code_and_metadata_size',value:v8Dump.numerics['bytecode_and_metadata_size'],descriptionPrefixBuilder:buildCodeAndMetadataSizeValueDescriptionPrefix});}<span class="fstat-no" title="function not covered" ></span>function addV8ComponentValues(componentDump,componentPath,addProcessScalar){<span class="cstat-no" title="statement not covered" ></span>tr.b.iterItems(CHROME_VALUE_PROPERTIES,<span class="fstat-no" title="function not covered" >function(propertyName,descriptionPrefixBuilder){<span class="cstat-no" title="statement not covered" ></span>addProcessScalar({source:'reported_by_chrome',component:componentPath,property:propertyName,value:componentDump.numerics[propertyName],descriptionPrefixBuilder:descriptionPrefixBuilder});}</span>);}<span class="fstat-no" title="function not covered" ></span>function buildProcessCountDescriptionPrefix(componentPath,processName){<span class="cstat-no" title="statement not covered" ></span>if(componentPath.length&gt;0){<span class="cstat-no" title="statement not covered" >throw new Error('Unexpected process count non-empty component path: '+componentPath.join(':'));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn'total number of '+convertProcessNameToUserFriendlyName(processName,true);}<span class="fstat-no" title="function not covered" ></span>function buildChromeValueDescriptionPrefix(formatSpec,componentPath,processName){<span class="cstat-no" title="statement not covered" ></span>var nameParts=[];<span class="cstat-no" title="statement not covered" >i</span>f(componentPath.length===0){<span class="cstat-no" title="statement not covered" >nameParts.push('total');<span class="cstat-no" title="statement not covered" >i</span>f(formatSpec.totalUserFriendlyPropertyName){<span class="cstat-no" title="statement not covered" >nameParts.push(formatSpec.totalUserFriendlyPropertyName);}</span>else{<span class="cstat-no" title="statement not covered" >if(formatSpec.userFriendlyPropertyNamePrefix)<span class="cstat-no" title="statement not covered" >nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);<span class="cstat-no" title="statement not covered" >n</span></span>ameParts.push(formatSpec.userFriendlyPropertyName);}<span class="cstat-no" title="statement not covered" ></span>n</span>ameParts.push('reported by Chrome for');}</span>else{<span class="cstat-no" title="statement not covered" >if(formatSpec.componentPreposition===undefined){<span class="cstat-no" title="statement not covered" >if(formatSpec.userFriendlyPropertyNamePrefix)<span class="cstat-no" title="statement not covered" >nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);<span class="cstat-no" title="statement not covered" >n</span></span>ameParts.push(componentPath.join(':'));<span class="cstat-no" title="statement not covered" >n</span>ameParts.push(formatSpec.userFriendlyPropertyName);}</span>else{<span class="cstat-no" title="statement not covered" >if(formatSpec.userFriendlyPropertyNamePrefix)<span class="cstat-no" title="statement not covered" >nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);<span class="cstat-no" title="statement not covered" >n</span></span>ameParts.push(formatSpec.userFriendlyPropertyName);<span class="cstat-no" title="statement not covered" >n</span>ameParts.push(formatSpec.componentPreposition);<span class="cstat-no" title="statement not covered" >i</span>f(componentPath[componentPath.length-1]==='allocated_by_malloc'){<span class="cstat-no" title="statement not covered" >nameParts.push('objects allocated by malloc for');<span class="cstat-no" title="statement not covered" >n</span>ameParts.push(componentPath.slice(0,componentPath.length-1).join(':'));}</span>else{<span class="cstat-no" title="statement not covered" >nameParts.push(componentPath.join(':'));}</span>}<span class="cstat-no" title="statement not covered" ></span>n</span>ameParts.push('in');}<span class="cstat-no" title="statement not covered" ></span>n</span>ameParts.push(convertProcessNameToUserFriendlyName(processName));<span class="cstat-no" title="statement not covered" >r</span>eturn nameParts.join(' ');}</span>var CHROME_VALUE_PROPERTIES={'effective_size':buildChromeValueDescriptionPrefix.bind(undefined,{userFriendlyPropertyName:'effective size',componentPreposition:'of'}),'allocated_objects_size':buildChromeValueDescriptionPrefix.bind(undefined,{userFriendlyPropertyName:'size of all objects allocated',totalUserFriendlyPropertyName:'size of all allocated objects',componentPreposition:'by'}),'locked_size':buildChromeValueDescriptionPrefix.bind(undefined,{userFriendlyPropertyName:'locked (pinned) size',componentPreposition:'of'}),'peak_size':buildChromeValueDescriptionPrefix.bind(undefined,{userFriendlyPropertyName:'peak size',componentPreposition:'of'})};var SYSTEM_TOTAL_VALUE_PROPERTIES={'resident_size':{getPropertyFunction:<span class="fstat-no" title="function not covered" >function(processDump){<span class="cstat-no" title="statement not covered" ></span>return processDump.totals.residentBytes;}</span>,descriptionPrefixBuilder:buildOsValueDescriptionPrefix.bind(undefined,'resident set size (RSS)')},'peak_resident_size':{getPropertyFunction:<span class="fstat-no" title="function not covered" >function(processDump){<span class="cstat-no" title="statement not covered" ></span>return processDump.totals.peakResidentBytes;}</span>,descriptionPrefixBuilder:buildOsValueDescriptionPrefix.bind(undefined,'peak resident set size')}};<span class="fstat-no" title="function not covered" >function addDetailedMemoryDumpValues(browserNameToGlobalDumps,values){<span class="cstat-no" title="statement not covered" ></span>addMemoryDumpValues(browserNameToGlobalDumps,g=&gt;<span class="cstat-no" title="statement not covered" >g.levelOfDetail===DETAILED,<span class="fstat-no" title="function not covered" ></span>function(processDump,addProcessScalar){<span class="cstat-no" title="statement not covered" ></span>tr.b.iterItems(SYSTEM_VALUE_COMPONENTS,<span class="fstat-no" title="function not covered" >function(componentName,componentSpec){<span class="cstat-no" title="statement not covered" ></span>tr.b.iterItems(SYSTEM_VALUE_PROPERTIES,<span class="fstat-no" title="function not covered" >function(propertyName,propertySpec){<span class="cstat-no" title="statement not covered" ></span>var node=getDescendantVmRegionClassificationNode(processDump.vmRegions,componentSpec.classificationPath);<span class="cstat-no" title="statement not covered" >v</span>ar componentPath=['system_memory'];<span class="cstat-no" title="statement not covered" >i</span>f(componentName)<span class="cstat-no" title="statement not covered" >componentPath.push(componentName);<span class="cstat-no" title="statement not covered" >a</span></span>ddProcessScalar({source:'reported_by_os',component:componentPath,property:propertyName,value:node===undefined?0:node.byteStats[propertySpec.byteStat]||0,unit:sizeInBytes_smallerIsBetter,descriptionPrefixBuilder:propertySpec.descriptionPrefixBuilder});}</span>);}</span>);<span class="cstat-no" title="statement not covered" >v</span>ar memtrackDump=processDump.getMemoryAllocatorDumpByFullName('gpu/android_memtrack');<span class="cstat-no" title="statement not covered" >i</span>f(memtrackDump!==undefined){<span class="cstat-no" title="statement not covered" >var descriptionPrefixBuilder=SYSTEM_VALUE_PROPERTIES['proportional_resident_size'].descriptionPrefixBuilder;<span class="cstat-no" title="statement not covered" >m</span>emtrackDump.children.forEach(<span class="fstat-no" title="function not covered" >function(memtrackChildDump){<span class="cstat-no" title="statement not covered" ></span>var childName=memtrackChildDump.name;<span class="cstat-no" title="statement not covered" >a</span>ddProcessScalar({source:'reported_by_os',component:['gpu_memory',childName],property:'proportional_resident_size',value:memtrackChildDump.numerics['memtrack_pss'],descriptionPrefixBuilder:descriptionPrefixBuilder});}</span>);}</span>}</span>,<span class="fstat-no" title="function not covered" >function(componentTree){</span>},values);}</span>var SYSTEM_VALUE_COMPONENTS={'':{classificationPath:[]},'java_heap':{classificationPath:['Android','Java runtime','Spaces'],userFriendlyName:'the Java heap'},'ashmem':{classificationPath:['Android','Ashmem'],userFriendlyName:'ashmem'},'native_heap':{classificationPath:['Native heap'],userFriendlyName:'the native heap'}};var SYSTEM_VALUE_PROPERTIES={'proportional_resident_size':{byteStat:'proportionalResident',descriptionPrefixBuilder:buildOsValueDescriptionPrefix.bind(undefined,'proportional resident size (PSS)')},'private_dirty_size':{byteStat:'privateDirtyResident',descriptionPrefixBuilder:buildOsValueDescriptionPrefix.bind(undefined,'private dirty size')}};<span class="fstat-no" title="function not covered" >function buildOsValueDescriptionPrefix(userFriendlyPropertyName,componentPath,processName){<span class="cstat-no" title="statement not covered" ></span>if(componentPath.length&gt;2){<span class="cstat-no" title="statement not covered" >throw new Error('OS value component path for \''+userFriendlyPropertyName+'\' too long: '+componentPath.join(':'));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar nameParts=[];<span class="cstat-no" title="statement not covered" >i</span>f(componentPath.length&lt;2)<span class="cstat-no" title="statement not covered" >nameParts.push('total');<span class="cstat-no" title="statement not covered" >n</span></span>ameParts.push(userFriendlyPropertyName);<span class="cstat-no" title="statement not covered" >i</span>f(componentPath.length&gt;0){<span class="cstat-no" title="statement not covered" >switch(componentPath[0]){case'system_memory':<span class="cstat-no" title="statement not covered" >if(componentPath.length&gt;1){<span class="cstat-no" title="statement not covered" >var userFriendlyComponentName=SYSTEM_VALUE_COMPONENTS[componentPath[1]].userFriendlyName;<span class="cstat-no" title="statement not covered" >i</span>f(userFriendlyComponentName===undefined){<span class="cstat-no" title="statement not covered" >throw new Error('System value sub-component for \''+userFriendlyPropertyName+'\' unknown: '+componentPath.join(':'));}<span class="cstat-no" title="statement not covered" ></span>n</span>ameParts.push('of',userFriendlyComponentName,'in');}</span>else{<span class="cstat-no" title="statement not covered" >nameParts.push('of system memory (RAM) used by');}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase'gpu_memory':<span class="cstat-no" title="statement not covered" >if(componentPath.length&gt;1){<span class="cstat-no" title="statement not covered" >nameParts.push('of the',componentPath[1]);<span class="cstat-no" title="statement not covered" >n</span>ameParts.push('Android memtrack component in');}</span>else{<span class="cstat-no" title="statement not covered" >nameParts.push('of GPU memory (Android memtrack) used by');}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error('OS value component for \''+userFriendlyPropertyName+'\' unknown: '+componentPath.join(':'));}</span>}</span>else{<span class="cstat-no" title="statement not covered" >nameParts.push('reported by the OS for');}<span class="cstat-no" title="statement not covered" ></span>n</span>ameParts.push(convertProcessNameToUserFriendlyName(processName));<span class="cstat-no" title="statement not covered" >r</span>eturn nameParts.join(' ');}<span class="fstat-no" title="function not covered" ></span>function buildCodeAndMetadataSizeValueDescriptionPrefix(componentPath,processName){<span class="cstat-no" title="statement not covered" ></span>return buildChromeValueDescriptionPrefix({userFriendlyPropertyNamePrefix:'size of',userFriendlyPropertyName:'code and metadata'},componentPath,processName);}<span class="fstat-no" title="function not covered" ></span>function getDescendantVmRegionClassificationNode(node,path){<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;path.length;i++){<span class="cstat-no" title="statement not covered" >if(node===undefined)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>ode=tr.b.findFirstInArray(node.children,c=&gt;<span class="cstat-no" title="statement not covered" >c.title===path[i])</span>;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn node;}<span class="fstat-no" title="function not covered" ></span>function addMemoryDumpCountValues(browserNameToGlobalDumps,values){<span class="cstat-no" title="statement not covered" ></span>browserNameToGlobalDumps.forEach(<span class="fstat-no" title="function not covered" >function(globalDumps,browserName){<span class="cstat-no" title="statement not covered" ></span>var totalDumpCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar levelOfDetailNameToDumpCount={};<span class="cstat-no" title="statement not covered" >L</span>EVEL_OF_DETAIL_NAMES.forEach(<span class="fstat-no" title="function not covered" >function(levelOfDetailName){<span class="cstat-no" title="statement not covered" ></span>levelOfDetailNameToDumpCount[levelOfDetailName]=0;}</span>);<span class="cstat-no" title="statement not covered" >g</span>lobalDumps.forEach(<span class="fstat-no" title="function not covered" >function(globalDump){<span class="cstat-no" title="statement not covered" ></span>totalDumpCount++;<span class="cstat-no" title="statement not covered" >v</span>ar levelOfDetailName=LEVEL_OF_DETAIL_NAMES.get(globalDump.levelOfDetail);<span class="cstat-no" title="statement not covered" >i</span>f(!(levelOfDetailName in levelOfDetailNameToDumpCount))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >l</span></span>evelOfDetailNameToDumpCount[levelOfDetailName]++;}</span>);<span class="cstat-no" title="statement not covered" >r</span>eportMemoryDumpCountAsValue(browserName,undefined,totalDumpCount,values);<span class="cstat-no" title="statement not covered" >t</span>r.b.iterItems(levelOfDetailNameToDumpCount,<span class="fstat-no" title="function not covered" >function(levelOfDetailName,levelOfDetailDumpCount){<span class="cstat-no" title="statement not covered" ></span>reportMemoryDumpCountAsValue(browserName,levelOfDetailName,levelOfDetailDumpCount,values);}</span>);}</span>);}<span class="fstat-no" title="function not covered" ></span>function reportMemoryDumpCountAsValue(browserName,levelOfDetailName,levelOfDetailDumpCount,values){<span class="cstat-no" title="statement not covered" ></span>var nameParts=['memory',browserName,'all_processes','dump_count'];<span class="cstat-no" title="statement not covered" >i</span>f(levelOfDetailName!==undefined)<span class="cstat-no" title="statement not covered" >nameParts.push(levelOfDetailName);<span class="cstat-no" title="statement not covered" >v</span></span>ar name=nameParts.join(':');<span class="cstat-no" title="statement not covered" >v</span>ar histogram=new tr.v.Histogram(name,count_smallerIsBetter,BOUNDARIES_FOR_UNIT_MAP.get(count_smallerIsBetter));<span class="cstat-no" title="statement not covered" >h</span>istogram.addSample(levelOfDetailDumpCount);<span class="cstat-no" title="statement not covered" >h</span>istogram.description=['total number of',levelOfDetailName||'all','memory dumps added by',convertBrowserNameToUserFriendlyName(browserName),'to the trace'].join(' ');<span class="cstat-no" title="statement not covered" >v</span>alues.addHistogram(histogram);}<span class="fstat-no" title="function not covered" ></span>function addMemoryDumpValues(browserNameToGlobalDumps,customGlobalDumpFilter,customProcessDumpValueExtractor,customComponentTreeModifier,values){<span class="cstat-no" title="statement not covered" ></span>browserNameToGlobalDumps.forEach(<span class="fstat-no" title="function not covered" >function(globalDumps,browserName){<span class="cstat-no" title="statement not covered" ></span>var filteredGlobalDumps=globalDumps.filter(customGlobalDumpFilter);<span class="cstat-no" title="statement not covered" >v</span>ar sourceToPropertyToData=extractDataFromGlobalDumps(filteredGlobalDumps,customProcessDumpValueExtractor);<span class="cstat-no" title="statement not covered" >r</span>eportDataAsValues(sourceToPropertyToData,browserName,customComponentTreeModifier,values);}</span>);}<span class="fstat-no" title="function not covered" ></span>function extractDataFromGlobalDumps(globalDumps,customProcessDumpValueExtractor){<span class="cstat-no" title="statement not covered" ></span>var sourceToPropertyToData=new Map();<span class="cstat-no" title="statement not covered" >v</span>ar dumpCount=globalDumps.length;<span class="cstat-no" title="statement not covered" >g</span>lobalDumps.forEach(<span class="fstat-no" title="function not covered" >function(globalDump,dumpIndex){<span class="cstat-no" title="statement not covered" ></span>tr.b.iterItems(globalDump.processMemoryDumps,<span class="fstat-no" title="function not covered" >function(_,processDump){<span class="cstat-no" title="statement not covered" ></span>extractDataFromProcessDump(processDump,sourceToPropertyToData,dumpIndex,dumpCount,customProcessDumpValueExtractor);}</span>);}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn sourceToPropertyToData;}<span class="fstat-no" title="function not covered" ></span>function extractDataFromProcessDump(processDump,sourceToPropertyToData,dumpIndex,dumpCount,customProcessDumpValueExtractor){<span class="cstat-no" title="statement not covered" ></span>var rawProcessName=processDump.process.name;<span class="cstat-no" title="statement not covered" >v</span>ar processNamePath=[canonicalizeProcessName(rawProcessName)];<span class="cstat-no" title="statement not covered" >c</span>ustomProcessDumpValueExtractor(processDump,<span class="fstat-no" title="function not covered" >function addProcessScalar(spec){<span class="cstat-no" title="statement not covered" ></span>if(spec.value===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar component=spec.component||[];<span class="fstat-no" title="function not covered" >f</span>unction createDetailsForErrorMessage(){<span class="cstat-no" title="statement not covered" ></span>var propertyUserFriendlyName=spec.property===undefined?'(undefined)':spec.property;<span class="cstat-no" title="statement not covered" >v</span>ar componentUserFriendlyName=component.length===0?'(empty)':component.join(':');<span class="cstat-no" title="statement not covered" >r</span>eturn['source=',spec.source,', property=',propertyUserFriendlyName,', component=',componentUserFriendlyName,' in ',processDump.process.userFriendlyName].join('');}<span class="cstat-no" title="statement not covered" ></span>var value,unit;<span class="cstat-no" title="statement not covered" >i</span>f(spec.value instanceof tr.v.ScalarNumeric){<span class="cstat-no" title="statement not covered" >value=spec.value.value;<span class="cstat-no" title="statement not covered" >u</span>nit=spec.value.unit;<span class="cstat-no" title="statement not covered" >i</span>f(spec.unit!==undefined){<span class="cstat-no" title="statement not covered" >throw new Error('Histogram value for '+createDetailsForErrorMessage()+' already specifies a unit');}</span>}</span>else{<span class="cstat-no" title="statement not covered" >value=spec.value;<span class="cstat-no" title="statement not covered" >u</span>nit=spec.unit;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propertyToData=sourceToPropertyToData.get(spec.source);<span class="cstat-no" title="statement not covered" >i</span>f(propertyToData===undefined){<span class="cstat-no" title="statement not covered" >propertyToData=new Map();<span class="cstat-no" title="statement not covered" >s</span>ourceToPropertyToData.set(spec.source,propertyToData);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar data=propertyToData.get(spec.property);<span class="cstat-no" title="statement not covered" >i</span>f(data===undefined){<span class="cstat-no" title="statement not covered" >data={processAndComponentTreeBuilder:new tr.b.MultiDimensionalViewBuilder(2,dumpCount),unit:unit,descriptionPrefixBuilder:spec.descriptionPrefixBuilder};<span class="cstat-no" title="statement not covered" >p</span>ropertyToData.set(spec.property,data);}</span>else <span class="cstat-no" title="statement not covered" >if(data.unit!==unit){<span class="cstat-no" title="statement not covered" >throw new Error('Multiple units provided for '+createDetailsForErrorMessage()+':'+data.unit.unitName+' and '+unit.unitName);}</span>else <span class="cstat-no" title="statement not covered" >if(data.descriptionPrefixBuilder!==spec.descriptionPrefixBuilder){<span class="cstat-no" title="statement not covered" >throw new Error('Multiple description prefix builders provided for'+createDetailsForErrorMessage());}<span class="cstat-no" title="statement not covered" ></span>v</span></span></span>ar values=new Array(dumpCount);<span class="cstat-no" title="statement not covered" >v</span>alues[dumpIndex]=value;<span class="cstat-no" title="statement not covered" >d</span>ata.processAndComponentTreeBuilder.addPath([processNamePath,component],values,tr.b.MultiDimensionalViewBuilder.ValueKind.TOTAL);}</span>);}<span class="fstat-no" title="function not covered" ></span>function reportDataAsValues(sourceToPropertyToData,browserName,customComponentTreeModifier,values){<span class="cstat-no" title="statement not covered" ></span>sourceToPropertyToData.forEach(<span class="fstat-no" title="function not covered" >function(propertyToData,sourceName){<span class="cstat-no" title="statement not covered" ></span>propertyToData.forEach(<span class="fstat-no" title="function not covered" >function(data,propertyName){<span class="cstat-no" title="statement not covered" ></span>var tree=data.processAndComponentTreeBuilder.buildTopDownTreeView();<span class="cstat-no" title="statement not covered" >v</span>ar unit=data.unit;<span class="cstat-no" title="statement not covered" >v</span>ar descriptionPrefixBuilder=data.descriptionPrefixBuilder;<span class="cstat-no" title="statement not covered" >c</span>ustomComponentTreeModifier(tree);<span class="cstat-no" title="statement not covered" >r</span>eportComponentDataAsValues(browserName,sourceName,propertyName,'all_processes',[],tree,unit,descriptionPrefixBuilder,values);<span class="cstat-no" title="statement not covered" >t</span>ree.children[0].forEach(<span class="fstat-no" title="function not covered" >function(processTree,processName){<span class="cstat-no" title="statement not covered" ></span>if(processTree.children[0].size&gt;0){<span class="cstat-no" title="statement not covered" >throw new Error('Multi-dimensional view node for source='+sourceName+', property='+(propertyName===undefined?'(undefined)':propertyName)+', process='+processName+' has children wrt the process name dimension');}<span class="cstat-no" title="statement not covered" ></span>c</span>ustomComponentTreeModifier(processTree);<span class="cstat-no" title="statement not covered" >r</span>eportComponentDataAsValues(browserName,sourceName,propertyName,processName,[],processTree,unit,descriptionPrefixBuilder,values);}</span>);}</span>);}</span>);}<span class="fstat-no" title="function not covered" ></span>function reportComponentDataAsValues(browserName,sourceName,propertyName,processName,componentPath,componentNode,unit,descriptionPrefixBuilder,values){<span class="cstat-no" title="statement not covered" ></span>var nameParts=['memory',browserName,processName,sourceName].concat(componentPath);<span class="cstat-no" title="statement not covered" >i</span>f(propertyName!==undefined)<span class="cstat-no" title="statement not covered" >nameParts.push(propertyName);<span class="cstat-no" title="statement not covered" >v</span></span>ar name=nameParts.join(':');<span class="cstat-no" title="statement not covered" >v</span>ar numeric=buildMemoryNumericFromNode(name,componentNode,unit);<span class="cstat-no" title="statement not covered" >n</span>umeric.description=[descriptionPrefixBuilder(componentPath,processName),'in',convertBrowserNameToUserFriendlyName(browserName)].join(' ');<span class="cstat-no" title="statement not covered" >v</span>alues.addHistogram(numeric);<span class="cstat-no" title="statement not covered" >v</span>ar depth=componentPath.length;<span class="cstat-no" title="statement not covered" >c</span>omponentPath.push(undefined);<span class="cstat-no" title="statement not covered" >c</span>omponentNode.children[1].forEach(<span class="fstat-no" title="function not covered" >function(childNode,childName){<span class="cstat-no" title="statement not covered" ></span>componentPath[depth]=childName;<span class="cstat-no" title="statement not covered" >r</span>eportComponentDataAsValues(browserName,sourceName,propertyName,processName,componentPath,childNode,unit,descriptionPrefixBuilder,values);}</span>);<span class="cstat-no" title="statement not covered" >c</span>omponentPath.pop();}<span class="fstat-no" title="function not covered" ></span>function buildMemoryNumericFromNode(name,node,unit){<span class="cstat-no" title="statement not covered" ></span>var histogram=new tr.v.Histogram(name,unit,BOUNDARIES_FOR_UNIT_MAP.get(unit));<span class="cstat-no" title="statement not covered" >n</span>ode.values.forEach(v=&gt;<span class="cstat-no" title="statement not covered" >histogram.addSample(v.total))</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn histogram;}</span>tr.metrics.MetricRegistry.register(memoryMetric,{supportsRangeOfInterest:true});return{memoryMetric:memoryMetric};});
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 14:22:44 GMT+0000 (UTC)</div>
</div>
</body>
</html>
