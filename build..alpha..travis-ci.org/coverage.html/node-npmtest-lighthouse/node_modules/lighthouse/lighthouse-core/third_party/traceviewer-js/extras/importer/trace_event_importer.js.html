<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/extras/importer/trace_event_importer.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-lighthouse">npmtest-lighthouse (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/extras/importer/trace_event_importer.js</span></h1>
    <h2>
        
        Statements: <span class="metric">4.64% <small>(62 / 1337)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0% <small>(0 / 744)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">1.25% <small>(1 / 80)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(1 / 1)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/extras/importer/</a> &#187; trace_event_importer.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2</td><td class="line-coverage"><span class="cline-any cline-yes">3</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";require("../../base/base64.js");require("../../base/color_scheme.js");require("../../base/range.js");require("../../base/unit.js");require("../../base/utils.js");require("./trace_code_entry.js");require("./trace_code_map.js");require("./v8/codemap.js");require("../../importer/context_processor.js");require("../../importer/importer.js");require("../../model/comment_box_annotation.js");require("../../model/constants.js");require("../../model/container_memory_dump.js");require("../../model/counter_series.js");require("../../model/flow_event.js");require("../../model/global_memory_dump.js");require("../../model/heap_dump.js");require("../../model/instant_event.js");require("../../model/memory_allocator_dump.js");require("../../model/model.js");require("../../model/process_memory_dump.js");require("../../model/rect_annotation.js");require("../../model/scoped_id.js");require("../../model/slice_group.js");require("../../model/vm_region.js");require("../../model/x_marker_annotation.js");require("../../value/numeric.js");'use strict';global.tr.exportTo('tr.e.importer',function(){var Base64=tr.b.Base64;var deepCopy=tr.b.deepCopy;var ColorScheme=tr.b.ColorScheme;<span class="fstat-no" title="function not covered" >function getEventColor(event,opt_customName){<span class="cstat-no" title="statement not covered" ></span>if(event.cname)<span class="cstat-no" title="statement not covered" >return ColorScheme.getColorIdForReservedName(event.cname);e</span>lse <span class="cstat-no" title="statement not covered" >if(opt_customName||event.name){<span class="cstat-no" title="statement not covered" >return ColorScheme.getColorIdForGeneralPurposeString(opt_customName||event.name);}</span>}</span></span>var PRODUCER='producer';var CONSUMER='consumer';var STEP='step';var BACKGROUND=tr.model.ContainerMemoryDump.LevelOfDetail.BACKGROUND;var LIGHT=tr.model.ContainerMemoryDump.LevelOfDetail.LIGHT;var DETAILED=tr.model.ContainerMemoryDump.LevelOfDetail.DETAILED;var MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER=[undefined,BACKGROUND,LIGHT,DETAILED];var GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX='global/';var ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX='ClockSyncEvent.';var BYTE_STAT_NAME_MAP={'pc':'privateCleanResident','pd':'privateDirtyResident','sc':'sharedCleanResident','sd':'sharedDirtyResident','pss':'proportionalResident','sw':'swapped'};var WEAK_MEMORY_ALLOCATOR_DUMP_FLAG=1&lt;&lt;0;var OBJECT_TYPE_NAME_PATTERNS=[{prefix:'const char *WTF::getStringWithTypeName() [T = ',suffix:']'},{prefix:'const char* WTF::getStringWithTypeName() [with T = ',suffix:']'},{prefix:'const char *__cdecl WTF::getStringWithTypeName&lt;',suffix:'&gt;(void)'}];var SUBTRACE_FIELDS=new Set(['powerTraceAsString','systemTraceEvents']);var NON_METADATA_FIELDS=new Set(['samples','stackFrames','traceAnnotations','traceEvents']);for(var subtraceField in SUBTRACE_FIELDS)NON_METADATA_FIELDS.add(subtraceField);<span class="fstat-no" title="function not covered" >function TraceEventImporter(model,eventData){<span class="cstat-no" title="statement not covered" ></span>this.importPriority=1;<span class="cstat-no" title="statement not covered" >t</span>his.model_=model;<span class="cstat-no" title="statement not covered" >t</span>his.events_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.sampleEvents_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.stackFrameEvents_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.subtraces_=[];<span class="cstat-no" title="statement not covered" >t</span>his.eventsWereFromString_=false;<span class="cstat-no" title="statement not covered" >t</span>his.softwareMeasuredCpuCount_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.allAsyncEvents_=[];<span class="cstat-no" title="statement not covered" >t</span>his.allFlowEvents_=[];<span class="cstat-no" title="statement not covered" >t</span>his.allObjectEvents_=[];<span class="cstat-no" title="statement not covered" >t</span>his.contextProcessorPerThread={};<span class="cstat-no" title="statement not covered" >t</span>his.traceEventSampleStackFramesByName_={};<span class="cstat-no" title="statement not covered" >t</span>his.v8ProcessCodeMaps_={};<span class="cstat-no" title="statement not covered" >t</span>his.v8ProcessRootStackFrame_={};<span class="cstat-no" title="statement not covered" >t</span>his.v8SamplingData_=[];<span class="cstat-no" title="statement not covered" >t</span>his.asyncClockSyncStart_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.asyncClockSyncFinish_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.allMemoryDumpEvents_={};<span class="cstat-no" title="statement not covered" >t</span>his.objectTypeNameMap_={};<span class="cstat-no" title="statement not covered" >t</span>his.clockDomainId_=tr.model.ClockDomainId.UNKNOWN_CHROME_LEGACY;<span class="cstat-no" title="statement not covered" >t</span>his.toModelTime_=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(typeof eventData==='string'||eventData instanceof String){<span class="cstat-no" title="statement not covered" >eventData=eventData.trim();<span class="cstat-no" title="statement not covered" >i</span>f(eventData[0]==='['){<span class="cstat-no" title="statement not covered" >eventData=eventData.replace(/\s*,\s*$/,'');<span class="cstat-no" title="statement not covered" >i</span>f(eventData[eventData.length-1]!==']')<span class="cstat-no" title="statement not covered" >eventData=eventData+']';}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.events_=JSON.parse(eventData);<span class="cstat-no" title="statement not covered" >t</span>his.eventsWereFromString_=true;}</span>else{<span class="cstat-no" title="statement not covered" >this.events_=eventData;}<span class="cstat-no" title="statement not covered" ></span>t</span>his.traceAnnotations_=this.events_.traceAnnotations;<span class="cstat-no" title="statement not covered" >i</span>f(this.events_.traceEvents){<span class="cstat-no" title="statement not covered" >var container=this.events_;<span class="cstat-no" title="statement not covered" >t</span>his.events_=this.events_.traceEvents;<span class="cstat-no" title="statement not covered" >f</span>or(var subtraceField of SUBTRACE_FIELDS)<span class="cstat-no" title="statement not covered" >if(container[subtraceField])<span class="cstat-no" title="statement not covered" >this.subtraces_.push(container[subtraceField]);<span class="cstat-no" title="statement not covered" >t</span></span></span>his.sampleEvents_=container.samples;<span class="cstat-no" title="statement not covered" >t</span>his.stackFrameEvents_=container.stackFrames;<span class="cstat-no" title="statement not covered" >i</span>f(container.displayTimeUnit){<span class="cstat-no" title="statement not covered" >var unitName=container.displayTimeUnit;<span class="cstat-no" title="statement not covered" >v</span>ar unit=tr.b.TimeDisplayModes[unitName];<span class="cstat-no" title="statement not covered" >i</span>f(unit===undefined){<span class="cstat-no" title="statement not covered" >throw new Error('Unit '+unitName+' is not supported.');}<span class="cstat-no" title="statement not covered" ></span>t</span>his.model_.intrinsicTimeUnit=unit;}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var fieldName in container){<span class="cstat-no" title="statement not covered" >if(NON_METADATA_FIELDS.has(fieldName))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >t</span></span>his.model_.metadata.push({name:fieldName,value:container[fieldName]});<span class="cstat-no" title="statement not covered" >i</span>f(fieldName==='metadata'){<span class="cstat-no" title="statement not covered" >var metadata=container[fieldName];<span class="cstat-no" title="statement not covered" >i</span>f(metadata['highres-ticks'])<span class="cstat-no" title="statement not covered" >this.model_.isTimeHighResolution=metadata['highres-ticks'];<span class="cstat-no" title="statement not covered" >i</span></span>f(metadata['clock-domain'])<span class="cstat-no" title="statement not covered" >this.clockDomainId_=metadata['clock-domain'];}</span></span>}</span>}</span>}</span>TraceEventImporter.canImport=<span class="fstat-no" title="function not covered" >function(eventData){<span class="cstat-no" title="statement not covered" ></span>if(typeof eventData==='string'||eventData instanceof String){<span class="cstat-no" title="statement not covered" >eventData=eventData.trim();<span class="cstat-no" title="statement not covered" >r</span>eturn eventData[0]==='{'||eventData[0]==='[';}<span class="cstat-no" title="statement not covered" ></span>i</span>f(eventData instanceof Array&amp;&amp;eventData.length&amp;&amp;eventData[0].ph)<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span></span>f(eventData.traceEvents){<span class="cstat-no" title="statement not covered" >if(eventData.traceEvents instanceof Array){<span class="cstat-no" title="statement not covered" >if(eventData.traceEvents.length&amp;&amp;eventData.traceEvents[0].ph)<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span></span>f(eventData.samples.length&amp;&amp;eventData.stackFrames!==undefined)<span class="cstat-no" title="statement not covered" >return true;}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span>;TraceEventImporter.prototype={__proto__:tr.importer.Importer.prototype,get importerName<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return'TraceEventImporter';}</span>,extractSubtraces:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var subtraces=this.subtraces_;<span class="cstat-no" title="statement not covered" >t</span>his.subtraces_=[];<span class="cstat-no" title="statement not covered" >r</span>eturn subtraces;}</span>,deepCopyIfNeeded_:<span class="fstat-no" title="function not covered" >function(obj){<span class="cstat-no" title="statement not covered" ></span>if(obj===undefined)<span class="cstat-no" title="statement not covered" >obj={};<span class="cstat-no" title="statement not covered" >i</span></span>f(this.eventsWereFromString_)<span class="cstat-no" title="statement not covered" >return obj;<span class="cstat-no" title="statement not covered" >r</span></span>eturn deepCopy(obj);}</span>,deepCopyAlways_:<span class="fstat-no" title="function not covered" >function(obj){<span class="cstat-no" title="statement not covered" ></span>if(obj===undefined)<span class="cstat-no" title="statement not covered" >obj={};<span class="cstat-no" title="statement not covered" >r</span></span>eturn deepCopy(obj);}</span>,processAsyncEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >t</span>his.allAsyncEvents_.push({sequenceNumber:this.allAsyncEvents_.length,event:event,thread:thread});}</span>,processFlowEvent:<span class="fstat-no" title="function not covered" >function(event,opt_slice){<span class="cstat-no" title="statement not covered" ></span>var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >t</span>his.allFlowEvents_.push({refGuid:tr.b.GUID.getLastSimpleGuid(),sequenceNumber:this.allFlowEvents_.length,event:event,slice:opt_slice,thread:thread});}</span>,processCounterEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>var ctrName;<span class="cstat-no" title="statement not covered" >i</span>f(event.id!==undefined)<span class="cstat-no" title="statement not covered" >ctrName=event.name+'['+event.id+']';e</span>lse <span class="cstat-no" title="statement not covered" >ctrName=event.name;<span class="cstat-no" title="statement not covered" >v</span></span>ar ctr=this.model_.getOrCreateProcess(event.pid).getOrCreateCounter(event.cat,ctrName);<span class="cstat-no" title="statement not covered" >v</span>ar reservedColorId=event.cname?getEventColor(event):undefined;<span class="cstat-no" title="statement not covered" >i</span>f(ctr.numSeries===0){<span class="cstat-no" title="statement not covered" >for(var seriesName in event.args){<span class="cstat-no" title="statement not covered" >var colorId=reservedColorId||getEventColor(event,ctr.name+'.'+seriesName);<span class="cstat-no" title="statement not covered" >c</span>tr.addSeries(new tr.model.CounterSeries(seriesName,colorId));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(ctr.numSeries===0){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'counter_parse_error',message:'Expected counter '+event.name+' to have at least one argument to use as a value.'});<span class="cstat-no" title="statement not covered" >d</span>elete ctr.parent.counters[ctr.name];<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar ts=this.toModelTimeFromUs_(event.ts);<span class="cstat-no" title="statement not covered" >c</span>tr.series.forEach(<span class="fstat-no" title="function not covered" >function(series){<span class="cstat-no" title="statement not covered" ></span>var val=event.args[series.name]?event.args[series.name]:0;<span class="cstat-no" title="statement not covered" >s</span>eries.addCounterSample(ts,val);}</span>);}</span>,scopedIdForEvent_:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>return new tr.model.ScopedId(event.scope||tr.model.OBJECT_DEFAULT_SCOPE,event.id);}</span>,processObjectEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >t</span>his.allObjectEvents_.push({sequenceNumber:this.allObjectEvents_.length,event:event,thread:thread});<span class="cstat-no" title="statement not covered" >i</span>f(thread.guid in this.contextProcessorPerThread){<span class="cstat-no" title="statement not covered" >var processor=this.contextProcessorPerThread[thread.guid];<span class="cstat-no" title="statement not covered" >v</span>ar scopedId=this.scopedIdForEvent_(event);<span class="cstat-no" title="statement not covered" >i</span>f(event.ph==='D')<span class="cstat-no" title="statement not covered" >processor.destroyContext(scopedId);<span class="cstat-no" title="statement not covered" >p</span></span>rocessor.invalidateContextCacheForSnapshot(scopedId);}</span>}</span>,processContextEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >i</span>f(!(thread.guid in this.contextProcessorPerThread)){<span class="cstat-no" title="statement not covered" >this.contextProcessorPerThread[thread.guid]=new tr.importer.ContextProcessor(this.model_);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar scopedId=this.scopedIdForEvent_(event);<span class="cstat-no" title="statement not covered" >v</span>ar contextType=event.name;<span class="cstat-no" title="statement not covered" >v</span>ar processor=this.contextProcessorPerThread[thread.guid];<span class="cstat-no" title="statement not covered" >i</span>f(event.ph==='('){<span class="cstat-no" title="statement not covered" >processor.enterContext(contextType,scopedId);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph===')'){<span class="cstat-no" title="statement not covered" >processor.leaveContext(contextType,scopedId);}</span>else{<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'unknown_context_phase',message:'Unknown context event phase: '+event.ph+'.'});}</span>}</span></span>,setContextsFromThread_:<span class="fstat-no" title="function not covered" >function(thread,slice){<span class="cstat-no" title="statement not covered" ></span>if(thread.guid in this.contextProcessorPerThread){<span class="cstat-no" title="statement not covered" >slice.contexts=this.contextProcessorPerThread[thread.guid].activeContexts;}</span>}</span>,processDurationEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >v</span>ar ts=this.toModelTimeFromUs_(event.ts);<span class="cstat-no" title="statement not covered" >i</span>f(!thread.sliceGroup.isTimestampValidForBeginOrEnd(ts)){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'duration_parse_error',message:'Timestamps are moving backward.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.ph==='B'){<span class="cstat-no" title="statement not covered" >var slice=thread.sliceGroup.beginSlice(event.cat,event.name,this.toModelTimeFromUs_(event.ts),this.deepCopyIfNeeded_(event.args),this.toModelTimeFromUs_(event.tts),event.argsStripped,getEventColor(event));<span class="cstat-no" title="statement not covered" >s</span>lice.startStackFrame=this.getStackFrameForEvent_(event);<span class="cstat-no" title="statement not covered" >t</span>his.setContextsFromThread_(thread,slice);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='I'||event.ph==='i'||event.ph==='R'){<span class="cstat-no" title="statement not covered" >if(event.s!==undefined&amp;&amp;event.s!=='t')<span class="cstat-no" title="statement not covered" >throw new Error('This should never happen');<span class="cstat-no" title="statement not covered" >t</span></span>hread.sliceGroup.beginSlice(event.cat,event.name,this.toModelTimeFromUs_(event.ts),this.deepCopyIfNeeded_(event.args),this.toModelTimeFromUs_(event.tts),event.argsStripped,getEventColor(event));<span class="cstat-no" title="statement not covered" >v</span>ar slice=thread.sliceGroup.endSlice(this.toModelTimeFromUs_(event.ts),this.toModelTimeFromUs_(event.tts));<span class="cstat-no" title="statement not covered" >s</span>lice.startStackFrame=this.getStackFrameForEvent_(event);<span class="cstat-no" title="statement not covered" >s</span>lice.endStackFrame=undefined;}</span>else{<span class="cstat-no" title="statement not covered" >if(!thread.sliceGroup.openSliceCount){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'duration_parse_error',message:'E phase event without a matching B phase event.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar slice=thread.sliceGroup.endSlice(this.toModelTimeFromUs_(event.ts),this.toModelTimeFromUs_(event.tts),getEventColor(event));<span class="cstat-no" title="statement not covered" >i</span>f(event.name&amp;&amp;slice.title!=event.name){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'title_match_error',message:'Titles do not match. Title is '+slice.title+' in openSlice, and is '+event.name+' in endSlice'});}<span class="cstat-no" title="statement not covered" ></span>s</span>lice.endStackFrame=this.getStackFrameForEvent_(event);<span class="cstat-no" title="statement not covered" >t</span>his.mergeArgsInto_(slice.args,event.args,slice.title);}</span>}</span></span>,mergeArgsInto_:<span class="fstat-no" title="function not covered" >function(dstArgs,srcArgs,eventName){<span class="cstat-no" title="statement not covered" ></span>for(var arg in srcArgs){<span class="cstat-no" title="statement not covered" >if(dstArgs[arg]!==undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'arg_merge_error',message:'Different phases of '+eventName+' provided values for argument '+arg+'.'+' The last provided value will be used.'});}<span class="cstat-no" title="statement not covered" ></span>d</span>stArgs[arg]=this.deepCopyIfNeeded_(srcArgs[arg]);}</span>}</span>,processCompleteEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(event.cat!==undefined&amp;&amp;event.cat.indexOf('trace_event_overhead')&gt;-1)<span class="cstat-no" title="statement not covered" >return undefined;<span class="cstat-no" title="statement not covered" >v</span></span>ar thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >i</span>f(event.flow_out){<span class="cstat-no" title="statement not covered" >if(event.flow_in)<span class="cstat-no" title="statement not covered" >event.flowPhase=STEP;e</span>lse <span class="cstat-no" title="statement not covered" >event.flowPhase=PRODUCER;}</span></span>else <span class="cstat-no" title="statement not covered" >if(event.flow_in){<span class="cstat-no" title="statement not covered" >event.flowPhase=CONSUMER;}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar slice=thread.sliceGroup.pushCompleteSlice(event.cat,event.name,this.toModelTimeFromUs_(event.ts),this.maybeToModelTimeFromUs_(event.dur),this.maybeToModelTimeFromUs_(event.tts),this.maybeToModelTimeFromUs_(event.tdur),this.deepCopyIfNeeded_(event.args),event.argsStripped,getEventColor(event),event.bind_id);<span class="cstat-no" title="statement not covered" >s</span>lice.startStackFrame=this.getStackFrameForEvent_(event);<span class="cstat-no" title="statement not covered" >s</span>lice.endStackFrame=this.getStackFrameForEvent_(event,true);<span class="cstat-no" title="statement not covered" >t</span>his.setContextsFromThread_(thread,slice);<span class="cstat-no" title="statement not covered" >r</span>eturn slice;}</span>,processJitCodeEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(this.v8ProcessCodeMaps_[event.pid]===undefined)<span class="cstat-no" title="statement not covered" >this.v8ProcessCodeMaps_[event.pid]=new tr.e.importer.TraceCodeMap();<span class="cstat-no" title="statement not covered" >v</span></span>ar map=this.v8ProcessCodeMaps_[event.pid];<span class="cstat-no" title="statement not covered" >v</span>ar data=event.args.data;<span class="cstat-no" title="statement not covered" >i</span>f(event.name==='JitCodeMoved')<span class="cstat-no" title="statement not covered" >map.moveEntry(data.code_start,data.new_code_start,data.code_len);e</span>lse <span class="cstat-no" title="statement not covered" >map.addEntry(data.code_start,data.code_len,data.name,data.script_id);}</span></span>,processMetadataEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(event.name==='JitCodeAdded'||event.name==='JitCodeMoved'){<span class="cstat-no" title="statement not covered" >this.v8SamplingData_.push(event);<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.argsStripped)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(event.name==='process_name'){<span class="cstat-no" title="statement not covered" >var process=this.model_.getOrCreateProcess(event.pid);<span class="cstat-no" title="statement not covered" >p</span>rocess.name=event.args.name;}</span>else <span class="cstat-no" title="statement not covered" >if(event.name==='process_labels'){<span class="cstat-no" title="statement not covered" >var process=this.model_.getOrCreateProcess(event.pid);<span class="cstat-no" title="statement not covered" >v</span>ar labels=event.args.labels.split(',');<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;labels.length;i++)<span class="cstat-no" title="statement not covered" >process.addLabelIfNeeded(labels[i]);}</span></span>else <span class="cstat-no" title="statement not covered" >if(event.name==='process_sort_index'){<span class="cstat-no" title="statement not covered" >var process=this.model_.getOrCreateProcess(event.pid);<span class="cstat-no" title="statement not covered" >p</span>rocess.sortIndex=event.args.sort_index;}</span>else <span class="cstat-no" title="statement not covered" >if(event.name==='thread_name'){<span class="cstat-no" title="statement not covered" >var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >t</span>hread.name=event.args.name;}</span>else <span class="cstat-no" title="statement not covered" >if(event.name==='thread_sort_index'){<span class="cstat-no" title="statement not covered" >var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >t</span>hread.sortIndex=event.args.sort_index;}</span>else <span class="cstat-no" title="statement not covered" >if(event.name==='num_cpus'){<span class="cstat-no" title="statement not covered" >var n=event.args.number;<span class="cstat-no" title="statement not covered" >i</span>f(this.softwareMeasuredCpuCount_!==undefined)<span class="cstat-no" title="statement not covered" >n=Math.max(n,this.softwareMeasuredCpuCount_);<span class="cstat-no" title="statement not covered" >t</span></span>his.softwareMeasuredCpuCount_=n;}</span>else <span class="cstat-no" title="statement not covered" >if(event.name==='stackFrames'){<span class="cstat-no" title="statement not covered" >var stackFrames=event.args.stackFrames;<span class="cstat-no" title="statement not covered" >i</span>f(stackFrames===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'metadata_parse_error',message:'No stack frames found in a \''+event.name+'\' metadata event'});}</span>else{<span class="cstat-no" title="statement not covered" >this.importStackFrames_(stackFrames,'p'+event.pid+':');}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(event.name==='typeNames'){<span class="cstat-no" title="statement not covered" >var objectTypeNameMap=event.args.typeNames;<span class="cstat-no" title="statement not covered" >i</span>f(objectTypeNameMap===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'metadata_parse_error',message:'No mapping from object type IDs to names found in a \''+event.name+'\' metadata event'});}</span>else{<span class="cstat-no" title="statement not covered" >this.importObjectTypeNameMap_(objectTypeNameMap,event.pid);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(event.name==='TraceConfig'){<span class="cstat-no" title="statement not covered" >this.model_.metadata.push({name:'TraceConfig',value:event.args.value});}</span>else{<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'metadata_parse_error',message:'Unrecognized metadata name: '+event.name});}</span>}</span></span></span></span></span></span></span></span></span>,processInstantEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(event.name==='JitCodeAdded'||event.name==='JitCodeMoved'){<span class="cstat-no" title="statement not covered" >this.v8SamplingData_.push(event);<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.s==='t'||event.s===undefined){<span class="cstat-no" title="statement not covered" >this.processDurationEvent(event);<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar constructor;<span class="cstat-no" title="statement not covered" >s</span>witch(event.s){case'g':<span class="cstat-no" title="statement not covered" >constructor=tr.model.GlobalInstantEvent;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'p':<span class="cstat-no" title="statement not covered" >constructor=tr.model.ProcessInstantEvent;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'instant_parse_error',message:'I phase event with unknown "s" field value.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar instantEvent=new constructor(event.cat,event.name,getEventColor(event),this.toModelTimeFromUs_(event.ts),this.deepCopyIfNeeded_(event.args));<span class="cstat-no" title="statement not covered" >s</span>witch(instantEvent.type){case tr.model.InstantEventType.GLOBAL:<span class="cstat-no" title="statement not covered" >this.model_.instantEvents.push(instantEvent);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase tr.model.InstantEventType.PROCESS:<span class="cstat-no" title="statement not covered" >var process=this.model_.getOrCreateProcess(event.pid);<span class="cstat-no" title="statement not covered" >p</span>rocess.instantEvents.push(instantEvent);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error('Unknown instant event type: '+event.s);}</span>}</span>,processV8Sample:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>var data=event.args.data;<span class="cstat-no" title="statement not covered" >i</span>f(data.vm_state==='js'&amp;&amp;!data.stack.length)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar rootStackFrame=this.v8ProcessRootStackFrame_[event.pid];<span class="cstat-no" title="statement not covered" >i</span>f(!rootStackFrame){<span class="cstat-no" title="statement not covered" >rootStackFrame=new tr.model.StackFrame(undefined,'v8-root-stack-frame','v8-root-stack-frame',0);<span class="cstat-no" title="statement not covered" >t</span>his.v8ProcessRootStackFrame_[event.pid]=rootStackFrame;}<span class="fstat-no" title="function not covered" ></span>f</span>unction findChildWithEntryID(stackFrame,entryID){<span class="cstat-no" title="statement not covered" ></span>return tr.b.findFirstInArray(stackFrame.children,<span class="fstat-no" title="function not covered" >function(child){<span class="cstat-no" title="statement not covered" ></span>return child.entryID===entryID;}</span>);}<span class="cstat-no" title="statement not covered" ></span>var model=this.model_;<span class="fstat-no" title="function not covered" >f</span>unction addStackFrame(lastStackFrame,entry){<span class="cstat-no" title="statement not covered" ></span>var childFrame=findChildWithEntryID(lastStackFrame,entry.id);<span class="cstat-no" title="statement not covered" >i</span>f(childFrame)<span class="cstat-no" title="statement not covered" >return childFrame;<span class="cstat-no" title="statement not covered" >v</span></span>ar frame=new tr.model.StackFrame(lastStackFrame,tr.b.GUID.allocateSimple(),entry.name,ColorScheme.getColorIdForGeneralPurposeString(entry.name),entry.sourceInfo);<span class="cstat-no" title="statement not covered" >f</span>rame.entryID=entry.id;<span class="cstat-no" title="statement not covered" >m</span>odel.addStackFrame(frame);<span class="cstat-no" title="statement not covered" >r</span>eturn frame;}<span class="cstat-no" title="statement not covered" ></span>var lastStackFrame=rootStackFrame;<span class="cstat-no" title="statement not covered" >i</span>f(data.stack.length&gt;0&amp;&amp;this.v8ProcessCodeMaps_[event.pid]){<span class="cstat-no" title="statement not covered" >var map=this.v8ProcessCodeMaps_[event.pid];<span class="cstat-no" title="statement not covered" >d</span>ata.stack.reverse();<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;data.stack.length;i++){<span class="cstat-no" title="statement not covered" >var entry=map.lookupEntry(data.stack[i]);<span class="cstat-no" title="statement not covered" >i</span>f(entry===undefined){<span class="cstat-no" title="statement not covered" >entry={id:'unknown',name:'unknown',sourceInfo:undefined};}<span class="cstat-no" title="statement not covered" ></span>l</span>astStackFrame=addStackFrame(lastStackFrame,entry);}</span>}</span>else{<span class="cstat-no" title="statement not covered" >var entry={id:data.vm_state,name:data.vm_state,sourceInfo:undefined};<span class="cstat-no" title="statement not covered" >l</span>astStackFrame=addStackFrame(lastStackFrame,entry);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >v</span>ar sample=new tr.model.Sample(undefined,thread,'V8 Sample',this.toModelTimeFromUs_(event.ts),lastStackFrame,1,this.deepCopyIfNeeded_(event.args));<span class="cstat-no" title="statement not covered" >t</span>his.model_.samples.push(sample);}</span>,processTraceSampleEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(event.name==='V8Sample'){<span class="cstat-no" title="statement not covered" >this.v8SamplingData_.push(event);<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar stackFrame=this.getStackFrameForEvent_(event);<span class="cstat-no" title="statement not covered" >i</span>f(stackFrame===undefined){<span class="cstat-no" title="statement not covered" >stackFrame=this.traceEventSampleStackFramesByName_[event.name];}<span class="cstat-no" title="statement not covered" ></span>i</span>f(stackFrame===undefined){<span class="cstat-no" title="statement not covered" >var id='te-'+tr.b.GUID.allocateSimple();<span class="cstat-no" title="statement not covered" >s</span>tackFrame=new tr.model.StackFrame(undefined,id,event.name,ColorScheme.getColorIdForGeneralPurposeString(event.name));<span class="cstat-no" title="statement not covered" >t</span>his.model_.addStackFrame(stackFrame);<span class="cstat-no" title="statement not covered" >t</span>his.traceEventSampleStackFramesByName_[event.name]=stackFrame;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);<span class="cstat-no" title="statement not covered" >v</span>ar sample=new tr.model.Sample(undefined,thread,'Trace Event Sample',this.toModelTimeFromUs_(event.ts),stackFrame,1,this.deepCopyIfNeeded_(event.args));<span class="cstat-no" title="statement not covered" >t</span>his.setContextsFromThread_(thread,sample);<span class="cstat-no" title="statement not covered" >t</span>his.model_.samples.push(sample);}</span>,processMemoryDumpEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(event.ph!=='v')<span class="cstat-no" title="statement not covered" >throw new Error('Invalid memory dump event phase "'+event.ph+'".');<span class="cstat-no" title="statement not covered" >v</span></span>ar dumpId=event.id;<span class="cstat-no" title="statement not covered" >i</span>f(dumpId===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory dump event (phase \''+event.ph+'\') without a dump ID.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar pid=event.pid;<span class="cstat-no" title="statement not covered" >i</span>f(pid===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory dump event (phase\''+event.ph+'\', dump ID \''+dumpId+'\') without a PID.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar allEvents=this.allMemoryDumpEvents_;<span class="cstat-no" title="statement not covered" >v</span>ar dumpIdEvents=allEvents[dumpId];<span class="cstat-no" title="statement not covered" >i</span>f(dumpIdEvents===undefined)<span class="cstat-no" title="statement not covered" >allEvents[dumpId]=dumpIdEvents={};<span class="cstat-no" title="statement not covered" >v</span></span>ar processEvents=dumpIdEvents[pid];<span class="cstat-no" title="statement not covered" >i</span>f(processEvents===undefined)<span class="cstat-no" title="statement not covered" >dumpIdEvents[pid]=processEvents=[];<span class="cstat-no" title="statement not covered" >p</span></span>rocessEvents.push(event);}</span>,processClockSyncEvent:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(event.ph!=='c')<span class="cstat-no" title="statement not covered" >throw new Error('Invalid clock sync event phase "'+event.ph+'".');<span class="cstat-no" title="statement not covered" >v</span></span>ar syncId=event.args.sync_id;<span class="cstat-no" title="statement not covered" >i</span>f(syncId===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'clock_sync_parse_error',message:'Clock sync at time '+event.ts+' without an ID.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.args&amp;&amp;event.args.issue_ts!==undefined){<span class="cstat-no" title="statement not covered" >this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_,syncId,tr.b.Unit.timestampFromUs(event.args.issue_ts),tr.b.Unit.timestampFromUs(event.ts));}</span>else{<span class="cstat-no" title="statement not covered" >this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_,syncId,tr.b.Unit.timestampFromUs(event.ts));}</span>}</span>,processV8Events:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.v8SamplingData_.sort(<span class="fstat-no" title="function not covered" >function(a,b){<span class="cstat-no" title="statement not covered" ></span>if(a.ts!==b.ts)<span class="cstat-no" title="statement not covered" >return a.ts-b.ts;<span class="cstat-no" title="statement not covered" >i</span></span>f(a.ph==='M'||a.ph==='I')<span class="cstat-no" title="statement not covered" >return-1;e</span>lse <span class="cstat-no" title="statement not covered" >if(b.ph==='M'||b.ph==='I')<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn 0;}</span>);<span class="cstat-no" title="statement not covered" >v</span>ar length=this.v8SamplingData_.length;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;length;++i){<span class="cstat-no" title="statement not covered" >var event=this.v8SamplingData_[i];<span class="cstat-no" title="statement not covered" >i</span>f(event.ph==='M'||event.ph==='I'){<span class="cstat-no" title="statement not covered" >this.processJitCodeEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='P'){<span class="cstat-no" title="statement not covered" >this.processV8Sample(event);}</span>}</span></span>}</span>,initBackcompatClockSyncEventTracker_:<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(event.name!==undefined&amp;&amp;event.name.startsWith(ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX)&amp;&amp;event.ph==='S')<span class="cstat-no" title="statement not covered" >this.asyncClockSyncStart_=event;<span class="cstat-no" title="statement not covered" >i</span></span>f(event.name!==undefined&amp;&amp;event.name.startsWith(ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX)&amp;&amp;event.ph==='F')<span class="cstat-no" title="statement not covered" >this.asyncClockSyncFinish_=event;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.asyncClockSyncStart_==undefined||this.asyncClockSyncFinish_==undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar syncId=this.asyncClockSyncStart_.name.substring(ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX.length);<span class="cstat-no" title="statement not covered" >i</span>f(syncId!==this.asyncClockSyncFinish_.name.substring(ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX.length)){<span class="cstat-no" title="statement not covered" >throw new Error('Inconsistent clock sync id of async clock sync '+'events.');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar clockSyncEvent={ph:'c',args:{sync_id:syncId,issue_ts:this.asyncClockSyncStart_.ts},ts:this.asyncClockSyncFinish_.ts};<span class="cstat-no" title="statement not covered" >t</span>his.asyncClockSyncStart_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.asyncClockSyncFinish_=undefined;<span class="cstat-no" title="statement not covered" >r</span>eturn clockSyncEvent;}</span>,importClockSyncMarkers:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var asyncClockSyncStart,asyncClockSyncFinish;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;this.events_.length;i++){<span class="cstat-no" title="statement not covered" >var event=this.events_[i];<span class="cstat-no" title="statement not covered" >v</span>ar possibleBackCompatClockSyncEvent=this.initBackcompatClockSyncEventTracker_(event);<span class="cstat-no" title="statement not covered" >i</span>f(possibleBackCompatClockSyncEvent)<span class="cstat-no" title="statement not covered" >this.processClockSyncEvent(possibleBackCompatClockSyncEvent);<span class="cstat-no" title="statement not covered" >i</span></span>f(event.ph!=='c')<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar eventSizeInBytes=this.model_.importOptions.trackDetailedModelStats?JSON.stringify(event).length:undefined;<span class="cstat-no" title="statement not covered" >t</span>his.model_.stats.willProcessBasicTraceEvent('clock_sync',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processClockSyncEvent(event);}</span>}</span>,importEvents:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.stackFrameEvents_)<span class="cstat-no" title="statement not covered" >this.importStackFrames_(this.stackFrameEvents_,'g');<span class="cstat-no" title="statement not covered" >i</span></span>f(this.traceAnnotations_)<span class="cstat-no" title="statement not covered" >this.importAnnotations_();<span class="cstat-no" title="statement not covered" >v</span></span>ar importOptions=this.model_.importOptions;<span class="cstat-no" title="statement not covered" >v</span>ar trackDetailedModelStats=importOptions.trackDetailedModelStats;<span class="cstat-no" title="statement not covered" >v</span>ar modelStats=this.model_.stats;<span class="cstat-no" title="statement not covered" >v</span>ar events=this.events_;<span class="cstat-no" title="statement not covered" >f</span>or(var eI=0;eI&lt;events.length;eI++){<span class="cstat-no" title="statement not covered" >var event=events[eI];<span class="cstat-no" title="statement not covered" >i</span>f(event.args==='__stripped__'){<span class="cstat-no" title="statement not covered" >event.argsStripped=true;<span class="cstat-no" title="statement not covered" >e</span>vent.args=undefined;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar eventSizeInBytes;<span class="cstat-no" title="statement not covered" >i</span>f(trackDetailedModelStats)<span class="cstat-no" title="statement not covered" >eventSizeInBytes=JSON.stringify(event).length;e</span>lse <span class="cstat-no" title="statement not covered" >eventSizeInBytes=undefined;<span class="cstat-no" title="statement not covered" >i</span></span>f(event.ph==='B'||event.ph==='E'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('begin_end (non-compact)',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processDurationEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='X'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('begin_end (compact)',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >v</span>ar slice=this.processCompleteEvent(event);<span class="cstat-no" title="statement not covered" >i</span>f(slice!==undefined&amp;&amp;event.bind_id!==undefined)<span class="cstat-no" title="statement not covered" >this.processFlowEvent(event,slice);}</span></span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='b'||event.ph==='e'||event.ph==='n'||event.ph==='S'||event.ph==='F'||event.ph==='T'||event.ph==='p'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('async',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processAsyncEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='I'||event.ph==='i'||event.ph==='R'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('instant',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processInstantEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='P'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('samples',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processTraceSampleEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='C'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('counters',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processCounterEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='M'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('metadata',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processMetadataEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='N'||event.ph==='D'||event.ph==='O'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('objects',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processObjectEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='s'||event.ph==='t'||event.ph==='f'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('flows',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processFlowEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='v'){<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('memory_dumps',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.processMemoryDumpEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='('||event.ph===')'){<span class="cstat-no" title="statement not covered" >this.processContextEvent(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='c'){}else{<span class="cstat-no" title="statement not covered" >modelStats.willProcessBasicTraceEvent('unknown',event.cat,event.name,event.ts,eventSizeInBytes);<span class="cstat-no" title="statement not covered" >t</span>his.model_.importWarning({type:'parse_error',message:'Unrecognized event phase: '+event.ph+' ('+event.name+')'});}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span></span></span></span></span></span></span></span></span></span>t</span>his.processV8Events();<span class="cstat-no" title="statement not covered" >t</span>r.b.iterItems(this.v8ProcessRootStackFrame_,<span class="fstat-no" title="function not covered" >function(name,frame){<span class="cstat-no" title="statement not covered" ></span>frame.removeAllChildren();}</span>);}</span>,importStackFrames_:<span class="fstat-no" title="function not covered" >function(rawStackFrames,idPrefix){<span class="cstat-no" title="statement not covered" ></span>var model=this.model_;<span class="cstat-no" title="statement not covered" >f</span>or(var id in rawStackFrames){<span class="cstat-no" title="statement not covered" >var rawStackFrame=rawStackFrames[id];<span class="cstat-no" title="statement not covered" >v</span>ar fullId=idPrefix+id;<span class="cstat-no" title="statement not covered" >v</span>ar textForColor=rawStackFrame.category?rawStackFrame.category:rawStackFrame.name;<span class="cstat-no" title="statement not covered" >v</span>ar stackFrame=new tr.model.StackFrame(undefined,fullId,rawStackFrame.name,ColorScheme.getColorIdForGeneralPurposeString(textForColor));<span class="cstat-no" title="statement not covered" >m</span>odel.addStackFrame(stackFrame);}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var id in rawStackFrames){<span class="cstat-no" title="statement not covered" >var fullId=idPrefix+id;<span class="cstat-no" title="statement not covered" >v</span>ar stackFrame=model.stackFrames[fullId];<span class="cstat-no" title="statement not covered" >i</span>f(stackFrame===undefined)<span class="cstat-no" title="statement not covered" >throw new Error('Internal error');<span class="cstat-no" title="statement not covered" >v</span></span>ar rawStackFrame=rawStackFrames[id];<span class="cstat-no" title="statement not covered" >v</span>ar parentId=rawStackFrame.parent;<span class="cstat-no" title="statement not covered" >v</span>ar parentStackFrame;<span class="cstat-no" title="statement not covered" >i</span>f(parentId===undefined){<span class="cstat-no" title="statement not covered" >parentStackFrame=undefined;}</span>else{<span class="cstat-no" title="statement not covered" >var parentFullId=idPrefix+parentId;<span class="cstat-no" title="statement not covered" >p</span>arentStackFrame=model.stackFrames[parentFullId];<span class="cstat-no" title="statement not covered" >i</span>f(parentStackFrame===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'metadata_parse_error',message:'Missing parent frame with ID '+parentFullId+' for stack frame \''+stackFrame.name+'\' (ID '+fullId+').'});}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>tackFrame.parentFrame=parentStackFrame;}</span>}</span>,importObjectTypeNameMap_:<span class="fstat-no" title="function not covered" >function(rawObjectTypeNameMap,pid){<span class="cstat-no" title="statement not covered" ></span>if(pid in this.objectTypeNameMap_){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'metadata_parse_error',message:'Mapping from object type IDs to names provided for pid='+pid+' multiple times.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar objectTypeNamePrefix=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar objectTypeNameSuffix=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar objectTypeNameMap={};<span class="cstat-no" title="statement not covered" >f</span>or(var objectTypeId in rawObjectTypeNameMap){<span class="cstat-no" title="statement not covered" >var rawObjectTypeName=rawObjectTypeNameMap[objectTypeId];<span class="cstat-no" title="statement not covered" >i</span>f(objectTypeNamePrefix===undefined){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;OBJECT_TYPE_NAME_PATTERNS.length;i++){<span class="cstat-no" title="statement not covered" >var pattern=OBJECT_TYPE_NAME_PATTERNS[i];<span class="cstat-no" title="statement not covered" >i</span>f(rawObjectTypeName.startsWith(pattern.prefix)&amp;&amp;rawObjectTypeName.endsWith(pattern.suffix)){<span class="cstat-no" title="statement not covered" >objectTypeNamePrefix=pattern.prefix;<span class="cstat-no" title="statement not covered" >o</span>bjectTypeNameSuffix=pattern.suffix;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(objectTypeNamePrefix!==undefined&amp;&amp;rawObjectTypeName.startsWith(objectTypeNamePrefix)&amp;&amp;rawObjectTypeName.endsWith(objectTypeNameSuffix)){<span class="cstat-no" title="statement not covered" >objectTypeNameMap[objectTypeId]=rawObjectTypeName.substring(objectTypeNamePrefix.length,rawObjectTypeName.length-objectTypeNameSuffix.length);}</span>else{<span class="cstat-no" title="statement not covered" >objectTypeNameMap[objectTypeId]=rawObjectTypeName;}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.objectTypeNameMap_[pid]=objectTypeNameMap;}</span>,importAnnotations_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>for(var id in this.traceAnnotations_){<span class="cstat-no" title="statement not covered" >var annotation=tr.model.Annotation.fromDictIfPossible(this.traceAnnotations_[id]);<span class="cstat-no" title="statement not covered" >i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'annotation_warning',message:'Unrecognized traceAnnotation typeName \"'+this.traceAnnotations_[id].typeName+'\"'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>t</span>his.model_.addAnnotation(annotation);}</span>}</span>,finalizeImport:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.softwareMeasuredCpuCount_!==undefined){<span class="cstat-no" title="statement not covered" >this.model_.kernel.softwareMeasuredCpuCount=this.softwareMeasuredCpuCount_;}<span class="cstat-no" title="statement not covered" ></span>t</span>his.createAsyncSlices_();<span class="cstat-no" title="statement not covered" >t</span>his.createFlowSlices_();<span class="cstat-no" title="statement not covered" >t</span>his.createExplicitObjects_();<span class="cstat-no" title="statement not covered" >t</span>his.createImplicitObjects_();<span class="cstat-no" title="statement not covered" >t</span>his.createMemoryDumps_();}</span>,getStackFrameForEvent_:<span class="fstat-no" title="function not covered" >function(event,opt_lookForEndEvent){<span class="cstat-no" title="statement not covered" ></span>var sf;<span class="cstat-no" title="statement not covered" >v</span>ar stack;<span class="cstat-no" title="statement not covered" >i</span>f(opt_lookForEndEvent){<span class="cstat-no" title="statement not covered" >sf=event.esf;<span class="cstat-no" title="statement not covered" >s</span>tack=event.estack;}</span>else{<span class="cstat-no" title="statement not covered" >sf=event.sf;<span class="cstat-no" title="statement not covered" >s</span>tack=event.stack;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(stack!==undefined&amp;&amp;sf!==undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'stack_frame_and_stack_error',message:'Event at '+event.ts+' cannot have both a stack and a stackframe.'});<span class="cstat-no" title="statement not covered" >r</span>eturn undefined;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(stack!==undefined)<span class="cstat-no" title="statement not covered" >return this.model_.resolveStackToStackFrame_(event.pid,stack);<span class="cstat-no" title="statement not covered" >i</span></span>f(sf===undefined)<span class="cstat-no" title="statement not covered" >return undefined;<span class="cstat-no" title="statement not covered" >v</span></span>ar stackFrame=this.model_.stackFrames['g'+sf];<span class="cstat-no" title="statement not covered" >i</span>f(stackFrame===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'sample_import_error',message:'No frame for '+sf});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn stackFrame;}</span>,resolveStackToStackFrame_:<span class="fstat-no" title="function not covered" >function(pid,stack){<span class="cstat-no" title="statement not covered" ></span>return undefined;}</span>,importSampleData:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(!this.sampleEvents_)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar m=this.model_;<span class="cstat-no" title="statement not covered" >v</span>ar events=this.sampleEvents_;<span class="cstat-no" title="statement not covered" >i</span>f(this.events_.length===0){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;events.length;i++){<span class="cstat-no" title="statement not covered" >var event=events[i];<span class="cstat-no" title="statement not covered" >m</span>.getOrCreateProcess(event.tid).getOrCreateThread(event.tid);}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar threadsByTid={};<span class="cstat-no" title="statement not covered" >m</span>.getAllThreads().forEach(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>threadsByTid[t.tid]=t;}</span>);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;events.length;i++){<span class="cstat-no" title="statement not covered" >var event=events[i];<span class="cstat-no" title="statement not covered" >v</span>ar thread=threadsByTid[event.tid];<span class="cstat-no" title="statement not covered" >i</span>f(thread===undefined){<span class="cstat-no" title="statement not covered" >m.importWarning({type:'sample_import_error',message:'Thread '+events.tid+'not found'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar cpu;<span class="cstat-no" title="statement not covered" >i</span>f(event.cpu!==undefined)<span class="cstat-no" title="statement not covered" >cpu=m.kernel.getOrCreateCpu(event.cpu);<span class="cstat-no" title="statement not covered" >v</span></span>ar stackFrame=this.getStackFrameForEvent_(event);<span class="cstat-no" title="statement not covered" >v</span>ar sample=new tr.model.Sample(cpu,thread,event.name,this.toModelTimeFromUs_(event.ts),stackFrame,event.weight);<span class="cstat-no" title="statement not covered" >m</span>.samples.push(sample);}</span>}</span>,createAsyncSlices_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.allAsyncEvents_.length===0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.allAsyncEvents_.sort(<span class="fstat-no" title="function not covered" >function(x,y){<span class="cstat-no" title="statement not covered" ></span>var d=x.event.ts-y.event.ts;<span class="cstat-no" title="statement not covered" >i</span>f(d!==0)<span class="cstat-no" title="statement not covered" >return d;<span class="cstat-no" title="statement not covered" >r</span></span>eturn x.sequenceNumber-y.sequenceNumber;}</span>);<span class="cstat-no" title="statement not covered" >v</span>ar legacyEvents=[];<span class="cstat-no" title="statement not covered" >v</span>ar nestableAsyncEventsByKey={};<span class="cstat-no" title="statement not covered" >v</span>ar nestableMeasureAsyncEventsByKey={};<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;this.allAsyncEvents_.length;i++){<span class="cstat-no" title="statement not covered" >var asyncEventState=this.allAsyncEvents_[i];<span class="cstat-no" title="statement not covered" >v</span>ar event=asyncEventState.event;<span class="cstat-no" title="statement not covered" >i</span>f(event.ph==='S'||event.ph==='F'||event.ph==='T'||event.ph==='p'){<span class="cstat-no" title="statement not covered" >legacyEvents.push(asyncEventState);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.cat===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async events (ph: b, e, or n) require a '+'cat parameter.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.name===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async events (ph: b, e, or n) require a '+'name parameter.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.id===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async events (ph: b, e, or n) require an '+'id parameter.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.cat==='blink.user_timing'){<span class="cstat-no" title="statement not covered" >var matched=/([^\/:]+):([^\/:]+)\/?(.*)/.exec(event.name);<span class="cstat-no" title="statement not covered" >i</span>f(matched!==null){<span class="cstat-no" title="statement not covered" >var key=matched[1]+':'+event.cat;<span class="cstat-no" title="statement not covered" >e</span>vent.args=JSON.parse(Base64.atob(matched[3])||'{}');<span class="cstat-no" title="statement not covered" >i</span>f(nestableMeasureAsyncEventsByKey[key]===undefined)<span class="cstat-no" title="statement not covered" >nestableMeasureAsyncEventsByKey[key]=[];<span class="cstat-no" title="statement not covered" >n</span></span>estableMeasureAsyncEventsByKey[key].push(asyncEventState);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar key=event.cat+':'+event.id;<span class="cstat-no" title="statement not covered" >i</span>f(nestableAsyncEventsByKey[key]===undefined)<span class="cstat-no" title="statement not covered" >nestableAsyncEventsByKey[key]=[];<span class="cstat-no" title="statement not covered" >n</span></span>estableAsyncEventsByKey[key].push(asyncEventState);}<span class="cstat-no" title="statement not covered" ></span>t</span>his.createLegacyAsyncSlices_(legacyEvents);<span class="cstat-no" title="statement not covered" >t</span>his.createNestableAsyncSlices_(nestableMeasureAsyncEventsByKey);<span class="cstat-no" title="statement not covered" >t</span>his.createNestableAsyncSlices_(nestableAsyncEventsByKey);}</span>,createLegacyAsyncSlices_:<span class="fstat-no" title="function not covered" >function(legacyEvents){<span class="cstat-no" title="statement not covered" ></span>if(legacyEvents.length===0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >l</span></span>egacyEvents.sort(<span class="fstat-no" title="function not covered" >function(x,y){<span class="cstat-no" title="statement not covered" ></span>var d=x.event.ts-y.event.ts;<span class="cstat-no" title="statement not covered" >i</span>f(d!=0)<span class="cstat-no" title="statement not covered" >return d;<span class="cstat-no" title="statement not covered" >r</span></span>eturn x.sequenceNumber-y.sequenceNumber;}</span>);<span class="cstat-no" title="statement not covered" >v</span>ar asyncEventStatesByNameThenID={};<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;legacyEvents.length;i++){<span class="cstat-no" title="statement not covered" >var asyncEventState=legacyEvents[i];<span class="cstat-no" title="statement not covered" >v</span>ar event=asyncEventState.event;<span class="cstat-no" title="statement not covered" >v</span>ar name=event.name;<span class="cstat-no" title="statement not covered" >i</span>f(name===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'Async events (ph: S, T, p, or F) require a name '+' parameter.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar id=event.id;<span class="cstat-no" title="statement not covered" >i</span>f(id===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'Async events (ph: S, T, p, or F) require an id parameter.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.ph==='S'){<span class="cstat-no" title="statement not covered" >if(asyncEventStatesByNameThenID[name]===undefined)<span class="cstat-no" title="statement not covered" >asyncEventStatesByNameThenID[name]={};<span class="cstat-no" title="statement not covered" >i</span></span>f(asyncEventStatesByNameThenID[name][id]){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.ts+', a slice of the same id '+id+' was alrady open.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>a</span>syncEventStatesByNameThenID[name][id]=[];<span class="cstat-no" title="statement not covered" >a</span>syncEventStatesByNameThenID[name][id].push(asyncEventState);}</span>else{<span class="cstat-no" title="statement not covered" >if(asyncEventStatesByNameThenID[name]===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.ts+', no slice named '+name+' was open.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(asyncEventStatesByNameThenID[name][id]===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.ts+', no slice named '+name+' with id='+id+' was open.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar events=asyncEventStatesByNameThenID[name][id];<span class="cstat-no" title="statement not covered" >e</span>vents.push(asyncEventState);<span class="cstat-no" title="statement not covered" >i</span>f(event.ph==='F'){<span class="cstat-no" title="statement not covered" >var asyncSliceConstructor=tr.model.AsyncSlice.subTypes.getConstructor(events[0].event.cat,name);<span class="cstat-no" title="statement not covered" >v</span>ar slice=new asyncSliceConstructor(events[0].event.cat,name,getEventColor(events[0].event),this.toModelTimeFromUs_(events[0].event.ts),tr.b.concatenateObjects(events[0].event.args,events[events.length-1].event.args),this.toModelTimeFromUs_(event.ts-events[0].event.ts),true,undefined,undefined,events[0].event.argsStripped);<span class="cstat-no" title="statement not covered" >s</span>lice.startThread=events[0].thread;<span class="cstat-no" title="statement not covered" >s</span>lice.endThread=asyncEventState.thread;<span class="cstat-no" title="statement not covered" >s</span>lice.id=id;<span class="cstat-no" title="statement not covered" >v</span>ar stepType=events[1].event.ph;<span class="cstat-no" title="statement not covered" >v</span>ar isValid=true;<span class="cstat-no" title="statement not covered" >f</span>or(var j=1;j&lt;events.length-1;++j){<span class="cstat-no" title="statement not covered" >if(events[j].event.ph==='T'||events[j].event.ph==='p'){<span class="cstat-no" title="statement not covered" >isValid=this.assertStepTypeMatches_(stepType,events[j]);<span class="cstat-no" title="statement not covered" >i</span>f(!isValid)<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(events[j].event.ph==='S'){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.event.ts+', a slice named '+event.event.name+' with id='+event.event.id+' had a step before the start event.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(events[j].event.ph==='F'){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.event.ts+', a slice named '+event.event.name+' with id='+event.event.id+' had a step after the finish event.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar startIndex=j+(stepType==='T'?0:-1);<span class="cstat-no" title="statement not covered" >v</span>ar endIndex=startIndex+1;<span class="cstat-no" title="statement not covered" >v</span>ar subName=events[j].event.name;<span class="cstat-no" title="statement not covered" >i</span>f(!events[j].event.argsStripped&amp;&amp;(events[j].event.ph==='T'||events[j].event.ph==='p'))<span class="cstat-no" title="statement not covered" >subName=subName+':'+events[j].event.args.step;<span class="cstat-no" title="statement not covered" >v</span></span>ar asyncSliceConstructor=tr.model.AsyncSlice.subTypes.getConstructor(events[0].event.cat,subName);<span class="cstat-no" title="statement not covered" >v</span>ar subSlice=new asyncSliceConstructor(events[0].event.cat,subName,getEventColor(event,subName+j),this.toModelTimeFromUs_(events[startIndex].event.ts),this.deepCopyIfNeeded_(events[j].event.args),this.toModelTimeFromUs_(events[endIndex].event.ts-events[startIndex].event.ts),undefined,undefined,events[startIndex].event.argsStripped);<span class="cstat-no" title="statement not covered" >s</span>ubSlice.startThread=events[startIndex].thread;<span class="cstat-no" title="statement not covered" >s</span>ubSlice.endThread=events[endIndex].thread;<span class="cstat-no" title="statement not covered" >s</span>ubSlice.id=id;<span class="cstat-no" title="statement not covered" >s</span>lice.subSlices.push(subSlice);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isValid){<span class="cstat-no" title="statement not covered" >slice.startThread.asyncSliceGroup.push(slice);}<span class="cstat-no" title="statement not covered" ></span>d</span>elete asyncEventStatesByNameThenID[name][id];}</span>}</span>}</span>}</span>,createNestableAsyncSlices_:<span class="fstat-no" title="function not covered" >function(nestableEventsByKey){<span class="cstat-no" title="statement not covered" ></span>for(var key in nestableEventsByKey){<span class="cstat-no" title="statement not covered" >var eventStateEntries=nestableEventsByKey[key];<span class="cstat-no" title="statement not covered" >v</span>ar parentStack=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;eventStateEntries.length;++i){<span class="cstat-no" title="statement not covered" >var eventStateEntry=eventStateEntries[i];<span class="cstat-no" title="statement not covered" >i</span>f(eventStateEntry.event.ph==='e'){<span class="cstat-no" title="statement not covered" >var parentIndex=-1;<span class="cstat-no" title="statement not covered" >f</span>or(var k=parentStack.length-1;k&gt;=0;--k){<span class="cstat-no" title="statement not covered" >if(parentStack[k].event.name===eventStateEntry.event.name){<span class="cstat-no" title="statement not covered" >parentIndex=k;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(parentIndex===-1){<span class="cstat-no" title="statement not covered" >eventStateEntry.finished=false;}</span>else{<span class="cstat-no" title="statement not covered" >parentStack[parentIndex].end=eventStateEntry;<span class="cstat-no" title="statement not covered" >w</span>hile(parentIndex&lt;parentStack.length){<span class="cstat-no" title="statement not covered" >parentStack.pop();}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(parentStack.length&gt;0)<span class="cstat-no" title="statement not covered" >eventStateEntry.parentEntry=parentStack[parentStack.length-1];<span class="cstat-no" title="statement not covered" >i</span></span>f(eventStateEntry.event.ph==='b'){<span class="cstat-no" title="statement not covered" >parentStack.push(eventStateEntry);}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar topLevelSlices=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;eventStateEntries.length;++i){<span class="cstat-no" title="statement not covered" >var eventStateEntry=eventStateEntries[i];<span class="cstat-no" title="statement not covered" >i</span>f(eventStateEntry.event.ph==='e'&amp;&amp;eventStateEntry.finished===undefined){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar startState=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar endState=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar sliceArgs=eventStateEntry.event.args||{};<span class="cstat-no" title="statement not covered" >v</span>ar sliceError=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(eventStateEntry.event.ph==='n'){<span class="cstat-no" title="statement not covered" >startState=eventStateEntry;<span class="cstat-no" title="statement not covered" >e</span>ndState=eventStateEntry;}</span>else <span class="cstat-no" title="statement not covered" >if(eventStateEntry.event.ph==='b'){<span class="cstat-no" title="statement not covered" >if(eventStateEntry.end===undefined){<span class="cstat-no" title="statement not covered" >eventStateEntry.end=eventStateEntries[eventStateEntries.length-1];<span class="cstat-no" title="statement not covered" >s</span>liceError='Slice has no matching END. End time has been adjusted.';<span class="cstat-no" title="statement not covered" >t</span>his.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async BEGIN event at '+eventStateEntry.event.ts+' with name='+eventStateEntry.event.name+' and id='+eventStateEntry.event.id+' was unmatched.'});}</span>else{<span class="fstat-no" title="function not covered" >function concatenateArguments(args1,args2){<span class="cstat-no" title="statement not covered" ></span>if(args1.params===undefined||args2.params===undefined)<span class="cstat-no" title="statement not covered" >return tr.b.concatenateObjects(args1,args2);<span class="cstat-no" title="statement not covered" >v</span></span>ar args3={};<span class="cstat-no" title="statement not covered" >a</span>rgs3.params=tr.b.concatenateObjects(args1.params,args2.params);<span class="cstat-no" title="statement not covered" >r</span>eturn tr.b.concatenateObjects(args1,args2,args3);}<span class="cstat-no" title="statement not covered" ></span>var endArgs=eventStateEntry.end.event.args||{};<span class="cstat-no" title="statement not covered" >s</span>liceArgs=concatenateArguments(sliceArgs,endArgs);}<span class="cstat-no" title="statement not covered" ></span>s</span>tartState=eventStateEntry;<span class="cstat-no" title="statement not covered" >e</span>ndState=eventStateEntry.end;}</span>else{<span class="cstat-no" title="statement not covered" >sliceError='Slice has no matching BEGIN. Start time has been adjusted.';<span class="cstat-no" title="statement not covered" >t</span>his.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async END event at '+eventStateEntry.event.ts+' with name='+eventStateEntry.event.name+' and id='+eventStateEntry.event.id+' was unmatched.'});<span class="cstat-no" title="statement not covered" >s</span>tartState=eventStateEntries[0];<span class="cstat-no" title="statement not covered" >e</span>ndState=eventStateEntry;}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar isTopLevel=eventStateEntry.parentEntry===undefined;<span class="cstat-no" title="statement not covered" >v</span>ar asyncSliceConstructor=tr.model.AsyncSlice.subTypes.getConstructor(eventStateEntry.event.cat,eventStateEntry.event.name);<span class="cstat-no" title="statement not covered" >v</span>ar threadStart=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar threadDuration=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(startState.event.tts&amp;&amp;startState.event.use_async_tts){<span class="cstat-no" title="statement not covered" >threadStart=this.toModelTimeFromUs_(startState.event.tts);<span class="cstat-no" title="statement not covered" >i</span>f(endState.event.tts){<span class="cstat-no" title="statement not covered" >var threadEnd=this.toModelTimeFromUs_(endState.event.tts);<span class="cstat-no" title="statement not covered" >t</span>hreadDuration=threadEnd-threadStart;}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar slice=new asyncSliceConstructor(eventStateEntry.event.cat,eventStateEntry.event.name,getEventColor(endState.event),this.toModelTimeFromUs_(startState.event.ts),sliceArgs,this.toModelTimeFromUs_(endState.event.ts-startState.event.ts),isTopLevel,threadStart,threadDuration,startState.event.argsStripped);<span class="cstat-no" title="statement not covered" >s</span>lice.startThread=startState.thread;<span class="cstat-no" title="statement not covered" >s</span>lice.endThread=endState.thread;<span class="cstat-no" title="statement not covered" >s</span>lice.startStackFrame=this.getStackFrameForEvent_(startState.event);<span class="cstat-no" title="statement not covered" >s</span>lice.endStackFrame=this.getStackFrameForEvent_(endState.event);<span class="cstat-no" title="statement not covered" >s</span>lice.id=key;<span class="cstat-no" title="statement not covered" >i</span>f(sliceError!==undefined)<span class="cstat-no" title="statement not covered" >slice.error=sliceError;<span class="cstat-no" title="statement not covered" >e</span></span>ventStateEntry.slice=slice;<span class="cstat-no" title="statement not covered" >i</span>f(isTopLevel){<span class="cstat-no" title="statement not covered" >topLevelSlices.push(slice);}</span>else <span class="cstat-no" title="statement not covered" >if(eventStateEntry.parentEntry.slice!==undefined){<span class="cstat-no" title="statement not covered" >eventStateEntry.parentEntry.slice.subSlices.push(slice);}</span>}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var si=0;si&lt;topLevelSlices.length;si++){<span class="cstat-no" title="statement not covered" >topLevelSlices[si].startThread.asyncSliceGroup.push(topLevelSlices[si]);}</span>}</span>}</span>,assertStepTypeMatches_:<span class="fstat-no" title="function not covered" >function(stepType,event){<span class="cstat-no" title="statement not covered" ></span>if(stepType!=event.event.ph){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.event.ts+', a slice named '+event.event.name+' with id='+event.event.id+' had both begin and end steps, which is not allowed.'});<span class="cstat-no" title="statement not covered" >r</span>eturn false;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn true;}</span>,createFlowSlices_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.allFlowEvents_.length===0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar that=this;<span class="fstat-no" title="function not covered" >f</span>unction validateFlowEvent(){<span class="cstat-no" title="statement not covered" ></span>if(event.name===undefined){<span class="cstat-no" title="statement not covered" >that.model_.importWarning({type:'flow_slice_parse_error',message:'Flow events (ph: s, t or f) require a name parameter.'});<span class="cstat-no" title="statement not covered" >r</span>eturn false;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.ph==='s'||event.ph==='f'||event.ph==='t'){<span class="cstat-no" title="statement not covered" >if(event.id===undefined){<span class="cstat-no" title="statement not covered" >that.model_.importWarning({type:'flow_slice_parse_error',message:'Flow events (ph: s, t or f) require an id parameter.'});<span class="cstat-no" title="statement not covered" >r</span>eturn false;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(event.bind_id){<span class="cstat-no" title="statement not covered" >if(event.flow_in===undefined&amp;&amp;event.flow_out===undefined){<span class="cstat-no" title="statement not covered" >that.model_.importWarning({type:'flow_slice_parse_error',message:'Flow producer or consumer require flow_in or flow_out.'});<span class="cstat-no" title="statement not covered" >r</span>eturn false;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn true;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}<span class="cstat-no" title="statement not covered" ></span>var createFlowEvent=<span class="fstat-no" title="function not covered" >function(thread,event,opt_slice){<span class="cstat-no" title="statement not covered" ></span>var startSlice,flowId,flowStartTs;<span class="cstat-no" title="statement not covered" >i</span>f(event.bind_id){<span class="cstat-no" title="statement not covered" >startSlice=opt_slice;<span class="cstat-no" title="statement not covered" >f</span>lowId=event.bind_id;<span class="cstat-no" title="statement not covered" >f</span>lowStartTs=this.toModelTimeFromUs_(event.ts+event.dur);}</span>else{<span class="cstat-no" title="statement not covered" >var ts=this.toModelTimeFromUs_(event.ts);<span class="cstat-no" title="statement not covered" >s</span>tartSlice=thread.sliceGroup.findSliceAtTs(ts);<span class="cstat-no" title="statement not covered" >i</span>f(startSlice===undefined)<span class="cstat-no" title="statement not covered" >return undefined;<span class="cstat-no" title="statement not covered" >f</span></span>lowId=event.id;<span class="cstat-no" title="statement not covered" >f</span>lowStartTs=ts;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar flowEvent=new tr.model.FlowEvent(event.cat,flowId,event.name,getEventColor(event),flowStartTs,that.deepCopyAlways_(event.args));<span class="cstat-no" title="statement not covered" >f</span>lowEvent.startSlice=startSlice;<span class="cstat-no" title="statement not covered" >f</span>lowEvent.startStackFrame=that.getStackFrameForEvent_(event);<span class="cstat-no" title="statement not covered" >f</span>lowEvent.endStackFrame=undefined;<span class="cstat-no" title="statement not covered" >s</span>tartSlice.outFlowEvents.push(flowEvent);<span class="cstat-no" title="statement not covered" >r</span>eturn flowEvent;}</span>.bind(this);<span class="cstat-no" title="statement not covered" >v</span>ar finishFlowEventWith=<span class="fstat-no" title="function not covered" >function(flowEvent,thread,event,refGuid,bindToParent,opt_slice){<span class="cstat-no" title="statement not covered" ></span>var endSlice;<span class="cstat-no" title="statement not covered" >i</span>f(event.bind_id){<span class="cstat-no" title="statement not covered" >endSlice=opt_slice;}</span>else{<span class="cstat-no" title="statement not covered" >var ts=this.toModelTimeFromUs_(event.ts);<span class="cstat-no" title="statement not covered" >i</span>f(bindToParent){<span class="cstat-no" title="statement not covered" >endSlice=thread.sliceGroup.findSliceAtTs(ts);}</span>else{<span class="cstat-no" title="statement not covered" >endSlice=thread.sliceGroup.findNextSliceAfter(ts,refGuid);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(endSlice===undefined)<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span></span>e</span>ndSlice.inFlowEvents.push(flowEvent);<span class="cstat-no" title="statement not covered" >f</span>lowEvent.endSlice=endSlice;<span class="cstat-no" title="statement not covered" >f</span>lowEvent.duration=this.toModelTimeFromUs_(event.ts)-flowEvent.start;<span class="cstat-no" title="statement not covered" >f</span>lowEvent.endStackFrame=that.getStackFrameForEvent_(event);<span class="cstat-no" title="statement not covered" >t</span>hat.mergeArgsInto_(flowEvent.args,event.args,flowEvent.title);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>.bind(this);<span class="fstat-no" title="function not covered" >f</span>unction processFlowConsumer(flowIdToEvent,sliceGuidToEvent,event,slice){<span class="cstat-no" title="statement not covered" ></span>var flowEvent=flowIdToEvent[event.bind_id];<span class="cstat-no" title="statement not covered" >i</span>f(flowEvent===undefined){<span class="cstat-no" title="statement not covered" >that.model_.importWarning({type:'flow_slice_ordering_error',message:'Flow consumer '+event.bind_id+' does not have '+'a flow producer'});<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>else <span class="cstat-no" title="statement not covered" >if(flowEvent.endSlice){<span class="cstat-no" title="statement not covered" >var flowProducer=flowEvent.startSlice;<span class="cstat-no" title="statement not covered" >f</span>lowEvent=createFlowEvent(undefined,sliceGuidToEvent[flowProducer.guid],flowProducer);}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar ok=finishFlowEventWith(flowEvent,undefined,event,refGuid,undefined,slice);<span class="cstat-no" title="statement not covered" >i</span>f(ok){<span class="cstat-no" title="statement not covered" >that.model_.flowEvents.push(flowEvent);}</span>else{<span class="cstat-no" title="statement not covered" >that.model_.importWarning({type:'flow_slice_end_error',message:'Flow consumer '+event.bind_id+' does not end '+'at an actual slice, so cannot be created.'});<span class="cstat-no" title="statement not covered" >r</span>eturn false;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn true;}<span class="fstat-no" title="function not covered" ></span>function processFlowProducer(flowIdToEvent,flowStatus,event,slice){<span class="cstat-no" title="statement not covered" ></span>if(flowIdToEvent[event.bind_id]&amp;&amp;flowStatus[event.bind_id]){<span class="cstat-no" title="statement not covered" >that.model_.importWarning({type:'flow_slice_start_error',message:'Flow producer '+event.bind_id+' already seen'});<span class="cstat-no" title="statement not covered" >r</span>eturn false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar flowEvent=createFlowEvent(undefined,event,slice);<span class="cstat-no" title="statement not covered" >i</span>f(!flowEvent){<span class="cstat-no" title="statement not covered" >that.model_.importWarning({type:'flow_slice_start_error',message:'Flow producer '+event.bind_id+' does not start'+'a flow'});<span class="cstat-no" title="statement not covered" >r</span>eturn false;}<span class="cstat-no" title="statement not covered" ></span>f</span>lowIdToEvent[event.bind_id]=flowEvent;}<span class="cstat-no" title="statement not covered" ></span>this.allFlowEvents_.sort(<span class="fstat-no" title="function not covered" >function(x,y){<span class="cstat-no" title="statement not covered" ></span>var d=x.event.ts-y.event.ts;<span class="cstat-no" title="statement not covered" >i</span>f(d!=0)<span class="cstat-no" title="statement not covered" >return d;<span class="cstat-no" title="statement not covered" >r</span></span>eturn x.sequenceNumber-y.sequenceNumber;}</span>);<span class="cstat-no" title="statement not covered" >v</span>ar flowIdToEvent={};<span class="cstat-no" title="statement not covered" >v</span>ar sliceGuidToEvent={};<span class="cstat-no" title="statement not covered" >v</span>ar flowStatus={};<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;this.allFlowEvents_.length;++i){<span class="cstat-no" title="statement not covered" >var data=this.allFlowEvents_[i];<span class="cstat-no" title="statement not covered" >v</span>ar refGuid=data.refGuid;<span class="cstat-no" title="statement not covered" >v</span>ar event=data.event;<span class="cstat-no" title="statement not covered" >v</span>ar thread=data.thread;<span class="cstat-no" title="statement not covered" >i</span>f(!validateFlowEvent(event))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(event.bind_id){<span class="cstat-no" title="statement not covered" >var slice=data.slice;<span class="cstat-no" title="statement not covered" >s</span>liceGuidToEvent[slice.guid]=event;<span class="cstat-no" title="statement not covered" >i</span>f(event.flowPhase===PRODUCER){<span class="cstat-no" title="statement not covered" >if(!processFlowProducer(flowIdToEvent,flowStatus,event,slice))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>lowStatus[event.bind_id]=true;}</span>else{<span class="cstat-no" title="statement not covered" >if(!processFlowConsumer(flowIdToEvent,sliceGuidToEvent,event,slice))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>lowStatus[event.bind_id]=false;<span class="cstat-no" title="statement not covered" >i</span>f(event.flowPhase===STEP){<span class="cstat-no" title="statement not covered" >if(!processFlowProducer(flowIdToEvent,flowStatus,event,slice))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>lowStatus[event.bind_id]=true;}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar flowEvent;<span class="cstat-no" title="statement not covered" >i</span>f(event.ph==='s'){<span class="cstat-no" title="statement not covered" >if(flowIdToEvent[event.id]){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'flow_slice_start_error',message:'event id '+event.id+' already seen when '+'encountering start of flow event.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>f</span>lowEvent=createFlowEvent(thread,event);<span class="cstat-no" title="statement not covered" >i</span>f(!flowEvent){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'flow_slice_start_error',message:'event id '+event.id+' does not start '+'at an actual slice, so cannot be created.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>f</span>lowIdToEvent[event.id]=flowEvent;}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='t'||event.ph==='f'){<span class="cstat-no" title="statement not covered" >flowEvent=flowIdToEvent[event.id];<span class="cstat-no" title="statement not covered" >i</span>f(flowEvent===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'flow_slice_ordering_error',message:'Found flow phase '+event.ph+' for id: '+event.id+' but no flow start found.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar bindToParent=event.ph==='t';<span class="cstat-no" title="statement not covered" >i</span>f(event.ph==='f'){<span class="cstat-no" title="statement not covered" >if(event.bp===undefined){<span class="cstat-no" title="statement not covered" >if(event.cat.indexOf('input')&gt;-1)<span class="cstat-no" title="statement not covered" >bindToParent=true;e</span>lse <span class="cstat-no" title="statement not covered" >if(event.cat.indexOf('ipc.flow')&gt;-1)<span class="cstat-no" title="statement not covered" >bindToParent=true;}</span></span></span>else{<span class="cstat-no" title="statement not covered" >if(event.bp!=='e'){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'flow_slice_bind_point_error',message:'Flow event with invalid binding point (event.bp).'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>b</span>indToParent=true;}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar ok=finishFlowEventWith(flowEvent,thread,event,refGuid,bindToParent);<span class="cstat-no" title="statement not covered" >i</span>f(ok){<span class="cstat-no" title="statement not covered" >that.model_.flowEvents.push(flowEvent);}</span>else{<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'flow_slice_end_error',message:'event id '+event.id+' does not end '+'at an actual slice, so cannot be created.'});}<span class="cstat-no" title="statement not covered" ></span>f</span>lowIdToEvent[event.id]=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(ok&amp;&amp;event.ph==='t'){<span class="cstat-no" title="statement not covered" >flowEvent=createFlowEvent(thread,event);<span class="cstat-no" title="statement not covered" >f</span>lowIdToEvent[event.id]=flowEvent;}</span>}</span>}</span></span>}</span>,createExplicitObjects_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.allObjectEvents_.length===0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar processEvent=<span class="fstat-no" title="function not covered" >function(objectEventState){<span class="cstat-no" title="statement not covered" ></span>var event=objectEventState.event;<span class="cstat-no" title="statement not covered" >v</span>ar scopedId=this.scopedIdForEvent_(event);<span class="cstat-no" title="statement not covered" >v</span>ar thread=objectEventState.thread;<span class="cstat-no" title="statement not covered" >i</span>f(event.name===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'object_parse_error',message:'While processing '+JSON.stringify(event)+': '+'Object events require an name parameter.'});}<span class="cstat-no" title="statement not covered" ></span>i</span>f(scopedId.id===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'object_parse_error',message:'While processing '+JSON.stringify(event)+': '+'Object events require an id parameter.'});}<span class="cstat-no" title="statement not covered" ></span>v</span>ar process=thread.parent;<span class="cstat-no" title="statement not covered" >v</span>ar ts=this.toModelTimeFromUs_(event.ts);<span class="cstat-no" title="statement not covered" >v</span>ar instance;<span class="cstat-no" title="statement not covered" >i</span>f(event.ph==='N'){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >instance=process.objects.idWasCreated(scopedId,event.cat,event.name,ts);}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'object_parse_error',message:'While processing create of '+scopedId+' at ts='+ts+': '+e});<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='O'){<span class="cstat-no" title="statement not covered" >if(event.args.snapshot===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'object_parse_error',message:'While processing '+scopedId+' at ts='+ts+': '+'Snapshots must have args: {snapshot: ...}'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar snapshot;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >var args=this.deepCopyIfNeeded_(event.args.snapshot);<span class="cstat-no" title="statement not covered" >v</span>ar cat;<span class="cstat-no" title="statement not covered" >i</span>f(args.cat){<span class="cstat-no" title="statement not covered" >cat=args.cat;<span class="cstat-no" title="statement not covered" >d</span>elete args.cat;}</span>else{<span class="cstat-no" title="statement not covered" >cat=event.cat;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar baseTypename;<span class="cstat-no" title="statement not covered" >i</span>f(args.base_type){<span class="cstat-no" title="statement not covered" >baseTypename=args.base_type;<span class="cstat-no" title="statement not covered" >d</span>elete args.base_type;}</span>else{<span class="cstat-no" title="statement not covered" >baseTypename=undefined;}<span class="cstat-no" title="statement not covered" ></span>s</span>napshot=process.objects.addSnapshot(scopedId,cat,event.name,ts,args,baseTypename);<span class="cstat-no" title="statement not covered" >s</span>napshot.snapshottedOnThread=thread;}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'object_parse_error',message:'While processing snapshot of '+scopedId+' at ts='+ts+': '+e});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>i</span>nstance=snapshot.objectInstance;}</span>else <span class="cstat-no" title="statement not covered" >if(event.ph==='D'){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >process.objects.idWasDeleted(scopedId,event.cat,event.name,ts);<span class="cstat-no" title="statement not covered" >v</span>ar instanceMap=process.objects.getOrCreateInstanceMap_(scopedId);<span class="cstat-no" title="statement not covered" >i</span>nstance=instanceMap.lastInstance;}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'object_parse_error',message:'While processing delete of '+scopedId+' at ts='+ts+': '+e});<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span>f(instance)<span class="cstat-no" title="statement not covered" >instance.colorId=getEventColor(event,instance.typeName);}</span></span>.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his.allObjectEvents_.sort(<span class="fstat-no" title="function not covered" >function(x,y){<span class="cstat-no" title="statement not covered" ></span>var d=x.event.ts-y.event.ts;<span class="cstat-no" title="statement not covered" >i</span>f(d!=0)<span class="cstat-no" title="statement not covered" >return d;<span class="cstat-no" title="statement not covered" >r</span></span>eturn x.sequenceNumber-y.sequenceNumber;}</span>);<span class="cstat-no" title="statement not covered" >v</span>ar allObjectEvents=this.allObjectEvents_;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;allObjectEvents.length;i++){<span class="cstat-no" title="statement not covered" >var objectEventState=allObjectEvents[i];<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >processEvent.call(this,objectEventState);}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'object_parse_error',message:e.message});}</span>}</span>}</span>,createImplicitObjects_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>tr.b.iterItems(this.model_.processes,<span class="fstat-no" title="function not covered" >function(pid,process){<span class="cstat-no" title="statement not covered" ></span>this.createImplicitObjectsForProcess_(process);}</span>,this);}</span>,createImplicitObjectsForProcess_:<span class="fstat-no" title="function not covered" >function(process){<span class="fstat-no" title="function not covered" ></span>function processField(referencingObject,referencingObjectFieldName,referencingObjectFieldValue,containingSnapshot){<span class="cstat-no" title="statement not covered" ></span>if(!referencingObjectFieldValue)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(referencingObjectFieldValue instanceof tr.model.ObjectSnapshot)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(referencingObjectFieldValue.id===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar implicitSnapshot=referencingObjectFieldValue;<span class="cstat-no" title="statement not covered" >v</span>ar rawId=implicitSnapshot.id;<span class="cstat-no" title="statement not covered" >v</span>ar m=/(.+)\/(.+)/.exec(rawId);<span class="cstat-no" title="statement not covered" >i</span>f(!m)<span class="cstat-no" title="statement not covered" >throw new Error('Implicit snapshots must have names.');<span class="cstat-no" title="statement not covered" >d</span></span>elete implicitSnapshot.id;<span class="cstat-no" title="statement not covered" >v</span>ar name=m[1];<span class="cstat-no" title="statement not covered" >v</span>ar id=m[2];<span class="cstat-no" title="statement not covered" >v</span>ar res;<span class="cstat-no" title="statement not covered" >v</span>ar cat;<span class="cstat-no" title="statement not covered" >i</span>f(implicitSnapshot.cat!==undefined)<span class="cstat-no" title="statement not covered" >cat=implicitSnapshot.cat;e</span>lse <span class="cstat-no" title="statement not covered" >cat=containingSnapshot.objectInstance.category;<span class="cstat-no" title="statement not covered" >v</span></span>ar baseTypename;<span class="cstat-no" title="statement not covered" >i</span>f(implicitSnapshot.base_type)<span class="cstat-no" title="statement not covered" >baseTypename=implicitSnapshot.base_type;e</span>lse <span class="cstat-no" title="statement not covered" >baseTypename=undefined;<span class="cstat-no" title="statement not covered" >v</span></span>ar scope=containingSnapshot.objectInstance.scopedId.scope;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >res=process.objects.addSnapshot(new tr.model.ScopedId(scope,id),cat,name,containingSnapshot.ts,implicitSnapshot,baseTypename);}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'object_snapshot_parse_error',message:'While processing implicit snapshot of '+rawId+' at ts='+containingSnapshot.ts+': '+e});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>r</span>es.objectInstance.hasImplicitSnapshots=true;<span class="cstat-no" title="statement not covered" >r</span>es.containingSnapshot=containingSnapshot;<span class="cstat-no" title="statement not covered" >r</span>es.snapshottedOnThread=containingSnapshot.snapshottedOnThread;<span class="cstat-no" title="statement not covered" >r</span>eferencingObject[referencingObjectFieldName]=res;<span class="cstat-no" title="statement not covered" >i</span>f(!(res instanceof tr.model.ObjectSnapshot))<span class="cstat-no" title="statement not covered" >throw new Error('Created object must be instanceof snapshot');<span class="cstat-no" title="statement not covered" >r</span></span>eturn res.args;}<span class="fstat-no" title="function not covered" ></span>function iterObject(object,func,containingSnapshot,thisArg){<span class="cstat-no" title="statement not covered" ></span>if(!(object instanceof Object))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(object instanceof Array){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;object.length;i++){<span class="cstat-no" title="statement not covered" >var res=func.call(thisArg,object,i,object[i],containingSnapshot);<span class="cstat-no" title="statement not covered" >i</span>f(res===null)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(res)<span class="cstat-no" title="statement not covered" >iterObject(res,func,containingSnapshot,thisArg);e</span>lse <span class="cstat-no" title="statement not covered" >iterObject(object[i],func,containingSnapshot,thisArg);}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var key in object){<span class="cstat-no" title="statement not covered" >var res=func.call(thisArg,object,key,object[key],containingSnapshot);<span class="cstat-no" title="statement not covered" >i</span>f(res===null)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(res)<span class="cstat-no" title="statement not covered" >iterObject(res,func,containingSnapshot,thisArg);e</span>lse <span class="cstat-no" title="statement not covered" >iterObject(object[key],func,containingSnapshot,thisArg);}</span></span>}<span class="cstat-no" title="statement not covered" ></span>process.objects.iterObjectInstances(<span class="fstat-no" title="function not covered" >function(instance){<span class="cstat-no" title="statement not covered" ></span>instance.snapshots.forEach(<span class="fstat-no" title="function not covered" >function(snapshot){<span class="cstat-no" title="statement not covered" ></span>if(snapshot.args.id!==undefined)<span class="cstat-no" title="statement not covered" >throw new Error('args cannot have an id field inside it');<span class="cstat-no" title="statement not covered" >i</span></span>terObject(snapshot.args,processField,snapshot,this);}</span>,this);}</span>,this);}</span>,createMemoryDumps_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>for(var dumpId in this.allMemoryDumpEvents_)<span class="cstat-no" title="statement not covered" >this.createGlobalMemoryDump_(this.allMemoryDumpEvents_[dumpId],dumpId);}</span></span>,createGlobalMemoryDump_:<span class="fstat-no" title="function not covered" >function(dumpIdEvents,dumpId){<span class="cstat-no" title="statement not covered" ></span>var globalRange=new tr.b.Range();<span class="cstat-no" title="statement not covered" >f</span>or(var pid in dumpIdEvents){<span class="cstat-no" title="statement not covered" >var processEvents=dumpIdEvents[pid];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;processEvents.length;i++)<span class="cstat-no" title="statement not covered" >globalRange.addValue(this.toModelTimeFromUs_(processEvents[i].ts));}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(globalRange.isEmpty)<span class="cstat-no" title="statement not covered" >throw new Error('Internal error: Global memory dump without events');<span class="cstat-no" title="statement not covered" >v</span></span>ar globalMemoryDump=new tr.model.GlobalMemoryDump(this.model_,globalRange.min);<span class="cstat-no" title="statement not covered" >g</span>lobalMemoryDump.duration=globalRange.range;<span class="cstat-no" title="statement not covered" >t</span>his.model_.globalMemoryDumps.push(globalMemoryDump);<span class="cstat-no" title="statement not covered" >v</span>ar globalMemoryAllocatorDumpsByFullName={};<span class="cstat-no" title="statement not covered" >v</span>ar levelsOfDetail={};<span class="cstat-no" title="statement not covered" >v</span>ar allMemoryAllocatorDumpsByGuid={};<span class="cstat-no" title="statement not covered" >f</span>or(var pid in dumpIdEvents){<span class="cstat-no" title="statement not covered" >this.createProcessMemoryDump_(globalMemoryDump,globalMemoryAllocatorDumpsByFullName,levelsOfDetail,allMemoryAllocatorDumpsByGuid,dumpIdEvents[pid],pid,dumpId);}<span class="cstat-no" title="statement not covered" ></span>g</span>lobalMemoryDump.levelOfDetail=levelsOfDetail.global;<span class="cstat-no" title="statement not covered" >g</span>lobalMemoryDump.memoryAllocatorDumps=this.inferMemoryAllocatorDumpTree_(globalMemoryAllocatorDumpsByFullName);<span class="cstat-no" title="statement not covered" >t</span>his.parseMemoryDumpAllocatorEdges_(allMemoryAllocatorDumpsByGuid,dumpIdEvents,dumpId);}</span>,createProcessMemoryDump_:<span class="fstat-no" title="function not covered" >function(globalMemoryDump,globalMemoryAllocatorDumpsByFullName,levelsOfDetail,allMemoryAllocatorDumpsByGuid,processEvents,pid,dumpId){<span class="cstat-no" title="statement not covered" ></span>var processRange=new tr.b.Range();<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;processEvents.length;i++)<span class="cstat-no" title="statement not covered" >processRange.addValue(this.toModelTimeFromUs_(processEvents[i].ts));<span class="cstat-no" title="statement not covered" >i</span></span>f(processRange.isEmpty)<span class="cstat-no" title="statement not covered" >throw new Error('Internal error: Process memory dump without events');<span class="cstat-no" title="statement not covered" >v</span></span>ar process=this.model_.getOrCreateProcess(pid);<span class="cstat-no" title="statement not covered" >v</span>ar processMemoryDump=new tr.model.ProcessMemoryDump(globalMemoryDump,process,processRange.min);<span class="cstat-no" title="statement not covered" >p</span>rocessMemoryDump.duration=processRange.range;<span class="cstat-no" title="statement not covered" >p</span>rocess.memoryDumps.push(processMemoryDump);<span class="cstat-no" title="statement not covered" >g</span>lobalMemoryDump.processMemoryDumps[pid]=processMemoryDump;<span class="cstat-no" title="statement not covered" >v</span>ar processMemoryAllocatorDumpsByFullName={};<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;processEvents.length;i++){<span class="cstat-no" title="statement not covered" >var processEvent=processEvents[i];<span class="cstat-no" title="statement not covered" >v</span>ar dumps=processEvent.args.dumps;<span class="cstat-no" title="statement not covered" >i</span>f(dumps===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'\'dumps\' field not found in a process memory dump'+' event for PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>t</span>his.parseMemoryDumpTotals_(processMemoryDump,dumps,pid,dumpId);<span class="cstat-no" title="statement not covered" >t</span>his.parseMemoryDumpVmRegions_(processMemoryDump,dumps,pid,dumpId);<span class="cstat-no" title="statement not covered" >t</span>his.parseMemoryDumpHeapDumps_(processMemoryDump,dumps,pid,dumpId);<span class="cstat-no" title="statement not covered" >t</span>his.parseMemoryDumpLevelOfDetail_(levelsOfDetail,dumps,pid,dumpId);<span class="cstat-no" title="statement not covered" >t</span>his.parseMemoryDumpAllocatorDumps_(processMemoryDump,globalMemoryDump,processMemoryAllocatorDumpsByFullName,globalMemoryAllocatorDumpsByFullName,allMemoryAllocatorDumpsByGuid,dumps,pid,dumpId);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(levelsOfDetail.process===undefined){<span class="cstat-no" title="statement not covered" >levelsOfDetail.process=processMemoryDump.vmRegions?DETAILED:LIGHT;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.updateMemoryDumpLevelOfDetail_(levelsOfDetail,'global',levelsOfDetail.process)){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'diffent levels of detail provided for global memory'+' dump (dump ID='+dumpId+').'});}<span class="cstat-no" title="statement not covered" ></span>p</span>rocessMemoryDump.levelOfDetail=levelsOfDetail.process;<span class="cstat-no" title="statement not covered" >d</span>elete levelsOfDetail.process;<span class="cstat-no" title="statement not covered" >p</span>rocessMemoryDump.memoryAllocatorDumps=this.inferMemoryAllocatorDumpTree_(processMemoryAllocatorDumpsByFullName);}</span>,parseMemoryDumpTotals_:<span class="fstat-no" title="function not covered" >function(processMemoryDump,dumps,pid,dumpId){<span class="cstat-no" title="statement not covered" ></span>var rawTotals=dumps.process_totals;<span class="cstat-no" title="statement not covered" >i</span>f(rawTotals===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(processMemoryDump.totals!==undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Process totals provided multiple times for'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar totals={};<span class="cstat-no" title="statement not covered" >v</span>ar platformSpecificTotals=undefined;<span class="cstat-no" title="statement not covered" >f</span>or(var rawTotalName in rawTotals){<span class="cstat-no" title="statement not covered" >var rawTotalValue=rawTotals[rawTotalName];<span class="cstat-no" title="statement not covered" >i</span>f(rawTotalValue===undefined)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(rawTotalName==='resident_set_bytes'){<span class="cstat-no" title="statement not covered" >totals.residentBytes=parseInt(rawTotalValue,16);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(rawTotalName==='peak_resident_set_bytes'){<span class="cstat-no" title="statement not covered" >totals.peakResidentBytes=parseInt(rawTotalValue,16);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(rawTotalName==='is_peak_rss_resetable'){<span class="cstat-no" title="statement not covered" >totals.arePeakResidentBytesResettable=!!rawTotalValue;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(platformSpecificTotals===undefined){<span class="cstat-no" title="statement not covered" >platformSpecificTotals={};<span class="cstat-no" title="statement not covered" >t</span>otals.platformSpecific=platformSpecificTotals;}<span class="cstat-no" title="statement not covered" ></span>p</span>latformSpecificTotals[rawTotalName]=parseInt(rawTotalValue,16);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(totals.peakResidentBytes===undefined&amp;&amp;totals.arePeakResidentBytesResettable!==undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Optional field peak_resident_set_bytes found'+' but is_peak_rss_resetable not found in'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});}<span class="cstat-no" title="statement not covered" ></span>i</span>f(totals.arePeakResidentBytesResettable!==undefined&amp;&amp;totals.peakResidentBytes===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Optional field is_peak_rss_resetable found'+' but peak_resident_set_bytes not found in'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});}<span class="cstat-no" title="statement not covered" ></span>p</span>rocessMemoryDump.totals=totals;}</span>,parseMemoryDumpVmRegions_:<span class="fstat-no" title="function not covered" >function(processMemoryDump,dumps,pid,dumpId){<span class="cstat-no" title="statement not covered" ></span>var rawProcessMmaps=dumps.process_mmaps;<span class="cstat-no" title="statement not covered" >i</span>f(rawProcessMmaps===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar rawVmRegions=rawProcessMmaps.vm_regions;<span class="cstat-no" title="statement not covered" >i</span>f(rawVmRegions===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(processMemoryDump.vmRegions!==undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'VM regions provided multiple times for'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar vmRegions=new Array(rawVmRegions.length);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;rawVmRegions.length;i++){<span class="cstat-no" title="statement not covered" >var rawVmRegion=rawVmRegions[i];<span class="cstat-no" title="statement not covered" >v</span>ar byteStats={};<span class="cstat-no" title="statement not covered" >v</span>ar rawByteStats=rawVmRegion.bs;<span class="cstat-no" title="statement not covered" >f</span>or(var rawByteStatName in rawByteStats){<span class="cstat-no" title="statement not covered" >var rawByteStatValue=rawByteStats[rawByteStatName];<span class="cstat-no" title="statement not covered" >i</span>f(rawByteStatValue===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Byte stat \''+rawByteStatName+'\' of VM region '+i+' ('+rawVmRegion.mf+') in process memory dump for '+'PID='+pid+' and dump ID='+dumpId+' does not have a value.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar byteStatName=BYTE_STAT_NAME_MAP[rawByteStatName];<span class="cstat-no" title="statement not covered" >i</span>f(byteStatName===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Unknown byte stat name \''+rawByteStatName+'\' ('+rawByteStatValue+') of VM region '+i+' ('+rawVmRegion.mf+') in process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>b</span>yteStats[byteStatName]=parseInt(rawByteStatValue,16);}<span class="cstat-no" title="statement not covered" ></span>v</span>mRegions[i]=new tr.model.VMRegion(parseInt(rawVmRegion.sa,16),parseInt(rawVmRegion.sz,16),rawVmRegion.pf,rawVmRegion.mf,byteStats);}<span class="cstat-no" title="statement not covered" ></span>p</span>rocessMemoryDump.vmRegions=tr.model.VMRegionClassificationNode.fromRegions(vmRegions);}</span>,parseMemoryDumpHeapDumps_:<span class="fstat-no" title="function not covered" >function(processMemoryDump,dumps,pid,dumpId){<span class="cstat-no" title="statement not covered" ></span>var rawHeapDumps=dumps.heaps;<span class="cstat-no" title="statement not covered" >i</span>f(rawHeapDumps===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(processMemoryDump.heapDumps!==undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Heap dumps provided multiple times for'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar model=this.model_;<span class="cstat-no" title="statement not covered" >v</span>ar idPrefix='p'+pid+':';<span class="cstat-no" title="statement not covered" >v</span>ar heapDumps={};<span class="cstat-no" title="statement not covered" >v</span>ar objectTypeNameMap=this.objectTypeNameMap_[pid];<span class="cstat-no" title="statement not covered" >i</span>f(objectTypeNameMap===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing mapping from object type IDs to names.'});}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var allocatorName in rawHeapDumps){<span class="cstat-no" title="statement not covered" >var entries=rawHeapDumps[allocatorName].entries;<span class="cstat-no" title="statement not covered" >i</span>f(entries===undefined||entries.length===0){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'No heap entries in a '+allocatorName+' heap dump for PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar isOldFormat=entries[0].bt===undefined;<span class="cstat-no" title="statement not covered" >i</span>f(!isOldFormat&amp;&amp;objectTypeNameMap===undefined){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar heapDump=new tr.model.HeapDump(processMemoryDump,allocatorName);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;entries.length;i++){<span class="cstat-no" title="statement not covered" >var entry=entries[i];<span class="cstat-no" title="statement not covered" >v</span>ar leafStackFrameIndex=entry.bt;<span class="cstat-no" title="statement not covered" >v</span>ar leafStackFrame;<span class="cstat-no" title="statement not covered" >i</span>f(isOldFormat){<span class="cstat-no" title="statement not covered" >if(leafStackFrameIndex===undefined){<span class="cstat-no" title="statement not covered" >leafStackFrame=undefined;}</span>else{<span class="cstat-no" title="statement not covered" >var leafStackFrameId=idPrefix+leafStackFrameIndex;<span class="cstat-no" title="statement not covered" >i</span>f(leafStackFrameIndex===''){<span class="cstat-no" title="statement not covered" >leafStackFrame=undefined;}</span>else{<span class="cstat-no" title="statement not covered" >leafStackFrame=model.stackFrames[leafStackFrameId];<span class="cstat-no" title="statement not covered" >i</span>f(leafStackFrame===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing leaf stack frame (ID '+leafStackFrameId+') of heap entry '+i+' (size '+size+') in a '+allocatorName+' heap dump for PID='+pid+'.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span>}<span class="cstat-no" title="statement not covered" ></span>l</span>eafStackFrameId+=':self';<span class="cstat-no" title="statement not covered" >i</span>f(model.stackFrames[leafStackFrameId]!==undefined){<span class="cstat-no" title="statement not covered" >leafStackFrame=model.stackFrames[leafStackFrameId];}</span>else{<span class="cstat-no" title="statement not covered" >leafStackFrame=new tr.model.StackFrame(leafStackFrame,leafStackFrameId,'&lt;self&gt;',undefined);<span class="cstat-no" title="statement not covered" >m</span>odel.addStackFrame(leafStackFrame);}</span>}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(leafStackFrameIndex===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing stack frame ID of heap entry '+i+' (size '+size+') in a '+allocatorName+' heap dump for PID='+pid+'.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar leafStackFrameId=idPrefix+leafStackFrameIndex;<span class="cstat-no" title="statement not covered" >i</span>f(leafStackFrameIndex===''){<span class="cstat-no" title="statement not covered" >leafStackFrame=undefined;}</span>else{<span class="cstat-no" title="statement not covered" >leafStackFrame=model.stackFrames[leafStackFrameId];<span class="cstat-no" title="statement not covered" >i</span>f(leafStackFrame===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing leaf stack frame (ID '+leafStackFrameId+') of heap entry '+i+' (size '+size+') in a '+allocatorName+' heap dump for PID='+pid+'.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar objectTypeId=entry.type;<span class="cstat-no" title="statement not covered" >v</span>ar objectTypeName;<span class="cstat-no" title="statement not covered" >i</span>f(objectTypeId===undefined){<span class="cstat-no" title="statement not covered" >objectTypeName=undefined;}</span>else <span class="cstat-no" title="statement not covered" >if(objectTypeNameMap===undefined){<span class="cstat-no" title="statement not covered" >continue;}</span>else{<span class="cstat-no" title="statement not covered" >objectTypeName=objectTypeNameMap[objectTypeId];<span class="cstat-no" title="statement not covered" >i</span>f(objectTypeName===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing object type name (ID '+objectTypeId+') of heap entry '+i+' (size '+size+') in a '+allocatorName+' heap dump for pid='+pid+'.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar size=parseInt(entry.size,16);<span class="cstat-no" title="statement not covered" >v</span>ar count=entry.count===undefined?undefined:parseInt(entry.count,16);<span class="cstat-no" title="statement not covered" >h</span>eapDump.addEntry(leafStackFrame,objectTypeName,size,count);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(heapDump.entries.length&gt;0)<span class="cstat-no" title="statement not covered" >heapDumps[allocatorName]=heapDump;}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(Object.keys(heapDumps).length&gt;0)<span class="cstat-no" title="statement not covered" >processMemoryDump.heapDumps=heapDumps;}</span></span>,parseMemoryDumpLevelOfDetail_:<span class="fstat-no" title="function not covered" >function(levelsOfDetail,dumps,pid,dumpId){<span class="cstat-no" title="statement not covered" ></span>var rawLevelOfDetail=dumps.level_of_detail;<span class="cstat-no" title="statement not covered" >v</span>ar level;<span class="cstat-no" title="statement not covered" >s</span>witch(rawLevelOfDetail){case'background':<span class="cstat-no" title="statement not covered" >level=BACKGROUND;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'light':<span class="cstat-no" title="statement not covered" >level=LIGHT;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'detailed':<span class="cstat-no" title="statement not covered" >level=DETAILED;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase undefined:<span class="cstat-no" title="statement not covered" >level=undefined;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'unknown raw level of detail \''+rawLevelOfDetail+'\' of process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.updateMemoryDumpLevelOfDetail_(levelsOfDetail,'process',level)){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'diffent levels of detail provided for process memory'+' dump for PID='+pid+' (dump ID='+dumpId+').'});}</span>}</span>,updateMemoryDumpLevelOfDetail_:<span class="fstat-no" title="function not covered" >function(levelsOfDetail,scope,level){<span class="cstat-no" title="statement not covered" ></span>if(!(scope in levelsOfDetail)||level===levelsOfDetail[scope]){<span class="cstat-no" title="statement not covered" >levelsOfDetail[scope]=level;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER.indexOf(level)&gt;MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER.indexOf(levelsOfDetail[scope])){<span class="cstat-no" title="statement not covered" >levelsOfDetail[scope]=level;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span>,parseMemoryDumpAllocatorDumps_:<span class="fstat-no" title="function not covered" >function(processMemoryDump,globalMemoryDump,processMemoryAllocatorDumpsByFullName,globalMemoryAllocatorDumpsByFullName,allMemoryAllocatorDumpsByGuid,dumps,pid,dumpId){<span class="cstat-no" title="statement not covered" ></span>var rawAllocatorDumps=dumps.allocators;<span class="cstat-no" title="statement not covered" >i</span>f(rawAllocatorDumps===undefined)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span></span>or(var fullName in rawAllocatorDumps){<span class="cstat-no" title="statement not covered" >var rawAllocatorDump=rawAllocatorDumps[fullName];<span class="cstat-no" title="statement not covered" >v</span>ar guid=rawAllocatorDump.guid;<span class="cstat-no" title="statement not covered" >i</span>f(guid===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump '+fullName+' for PID='+pid+' and dump ID='+dumpId+' does not have a GUID.'});}<span class="cstat-no" title="statement not covered" ></span>v</span>ar flags=rawAllocatorDump.flags||0;<span class="cstat-no" title="statement not covered" >v</span>ar isWeakDump=!!(flags&amp;WEAK_MEMORY_ALLOCATOR_DUMP_FLAG);<span class="cstat-no" title="statement not covered" >v</span>ar containerMemoryDump;<span class="cstat-no" title="statement not covered" >v</span>ar dstIndex;<span class="cstat-no" title="statement not covered" >i</span>f(fullName.startsWith(GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX)){<span class="cstat-no" title="statement not covered" >fullName=fullName.substring(GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX.length);<span class="cstat-no" title="statement not covered" >c</span>ontainerMemoryDump=globalMemoryDump;<span class="cstat-no" title="statement not covered" >d</span>stIndex=globalMemoryAllocatorDumpsByFullName;}</span>else{<span class="cstat-no" title="statement not covered" >containerMemoryDump=processMemoryDump;<span class="cstat-no" title="statement not covered" >d</span>stIndex=processMemoryAllocatorDumpsByFullName;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar allocatorDump=allMemoryAllocatorDumpsByGuid[guid];<span class="cstat-no" title="statement not covered" >i</span>f(allocatorDump===undefined){<span class="cstat-no" title="statement not covered" >if(fullName in dstIndex){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Multiple GUIDs provided for'+' memory allocator dump '+fullName+': '+dstIndex[fullName].guid+', '+guid+' (ignored) for'+' PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>a</span>llocatorDump=new tr.model.MemoryAllocatorDump(containerMemoryDump,fullName,guid);<span class="cstat-no" title="statement not covered" >a</span>llocatorDump.weak=isWeakDump;<span class="cstat-no" title="statement not covered" >d</span>stIndex[fullName]=allocatorDump;<span class="cstat-no" title="statement not covered" >i</span>f(guid!==undefined)<span class="cstat-no" title="statement not covered" >allMemoryAllocatorDumpsByGuid[guid]=allocatorDump;}</span></span>else{<span class="cstat-no" title="statement not covered" >if(allocatorDump.containerMemoryDump!==containerMemoryDump){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+' dumped in different contexts.'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(allocatorDump.fullName!==fullName){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump with GUID='+guid+' for PID='+pid+' and dump ID='+dumpId+' has multiple names: '+allocatorDump.fullName+', '+fullName+' (ignored).'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isWeakDump){<span class="cstat-no" title="statement not covered" >allocatorDump.weak=false;}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar attributes=rawAllocatorDump.attrs;<span class="cstat-no" title="statement not covered" >i</span>f(attributes===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+' does not have attributes.'});<span class="cstat-no" title="statement not covered" >a</span>ttributes={};}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var attrName in attributes){<span class="cstat-no" title="statement not covered" >var attrArgs=attributes[attrName];<span class="cstat-no" title="statement not covered" >v</span>ar attrType=attrArgs.type;<span class="cstat-no" title="statement not covered" >v</span>ar attrValue=attrArgs.value;<span class="cstat-no" title="statement not covered" >s</span>witch(attrType){case'scalar':<span class="cstat-no" title="statement not covered" >if(attrName in allocatorDump.numerics){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Multiple values provided for scalar attribute '+attrName+' of memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar unit=attrArgs.units==='bytes'?tr.b.Unit.byName.sizeInBytes_smallerIsBetter:tr.b.Unit.byName.unitlessNumber_smallerIsBetter;<span class="cstat-no" title="statement not covered" >v</span>ar value=parseInt(attrValue,16);<span class="cstat-no" title="statement not covered" >a</span>llocatorDump.addNumeric(attrName,new tr.v.ScalarNumeric(unit,value));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'string':<span class="cstat-no" title="statement not covered" >if(attrName in allocatorDump.diagnostics){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Multiple values provided for string attribute '+attrName+' of memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+'.'});<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>a</span>llocatorDump.addDiagnostic(attrName,attrValue);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Unknown type provided for attribute '+attrName+' of memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+': '+attrType});<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>}</span>}</span>,inferMemoryAllocatorDumpTree_:<span class="fstat-no" title="function not covered" >function(memoryAllocatorDumpsByFullName){<span class="cstat-no" title="statement not covered" ></span>var rootAllocatorDumps=[];<span class="cstat-no" title="statement not covered" >v</span>ar fullNames=Object.keys(memoryAllocatorDumpsByFullName);<span class="cstat-no" title="statement not covered" >f</span>ullNames.sort();<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;fullNames.length;i++){<span class="cstat-no" title="statement not covered" >var fullName=fullNames[i];<span class="cstat-no" title="statement not covered" >v</span>ar allocatorDump=memoryAllocatorDumpsByFullName[fullName];<span class="cstat-no" title="statement not covered" >w</span>hile(true){<span class="cstat-no" title="statement not covered" >var lastSlashIndex=fullName.lastIndexOf('/');<span class="cstat-no" title="statement not covered" >i</span>f(lastSlashIndex===-1){<span class="cstat-no" title="statement not covered" >rootAllocatorDumps.push(allocatorDump);<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar parentFullName=fullName.substring(0,lastSlashIndex);<span class="cstat-no" title="statement not covered" >v</span>ar parentAllocatorDump=memoryAllocatorDumpsByFullName[parentFullName];<span class="cstat-no" title="statement not covered" >v</span>ar parentAlreadyExisted=true;<span class="cstat-no" title="statement not covered" >i</span>f(parentAllocatorDump===undefined){<span class="cstat-no" title="statement not covered" >parentAlreadyExisted=false;<span class="cstat-no" title="statement not covered" >p</span>arentAllocatorDump=new tr.model.MemoryAllocatorDump(allocatorDump.containerMemoryDump,parentFullName);<span class="cstat-no" title="statement not covered" >i</span>f(allocatorDump.weak!==false){<span class="cstat-no" title="statement not covered" >parentAllocatorDump.weak=undefined;}<span class="cstat-no" title="statement not covered" ></span>m</span>emoryAllocatorDumpsByFullName[parentFullName]=parentAllocatorDump;}<span class="cstat-no" title="statement not covered" ></span>a</span>llocatorDump.parent=parentAllocatorDump;<span class="cstat-no" title="statement not covered" >p</span>arentAllocatorDump.children.push(allocatorDump);<span class="cstat-no" title="statement not covered" >i</span>f(parentAlreadyExisted){<span class="cstat-no" title="statement not covered" >if(!allocatorDump.weak){<span class="cstat-no" title="statement not covered" >while(parentAllocatorDump!==undefined&amp;&amp;parentAllocatorDump.weak===undefined){<span class="cstat-no" title="statement not covered" >parentAllocatorDump.weak=false;<span class="cstat-no" title="statement not covered" >p</span>arentAllocatorDump=parentAllocatorDump.parent;}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>f</span>ullName=parentFullName;<span class="cstat-no" title="statement not covered" >a</span>llocatorDump=parentAllocatorDump;}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var fullName in memoryAllocatorDumpsByFullName){<span class="cstat-no" title="statement not covered" >var allocatorDump=memoryAllocatorDumpsByFullName[fullName];<span class="cstat-no" title="statement not covered" >i</span>f(allocatorDump.weak===undefined)<span class="cstat-no" title="statement not covered" >allocatorDump.weak=true;}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn rootAllocatorDumps;}</span>,parseMemoryDumpAllocatorEdges_:<span class="fstat-no" title="function not covered" >function(allMemoryAllocatorDumpsByGuid,dumpIdEvents,dumpId){<span class="cstat-no" title="statement not covered" ></span>for(var pid in dumpIdEvents){<span class="cstat-no" title="statement not covered" >var processEvents=dumpIdEvents[pid];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;processEvents.length;i++){<span class="cstat-no" title="statement not covered" >var processEvent=processEvents[i];<span class="cstat-no" title="statement not covered" >v</span>ar dumps=processEvent.args.dumps;<span class="cstat-no" title="statement not covered" >i</span>f(dumps===undefined)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar rawEdges=dumps.allocators_graph;<span class="cstat-no" title="statement not covered" >i</span>f(rawEdges===undefined)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>or(var j=0;j&lt;rawEdges.length;j++){<span class="cstat-no" title="statement not covered" >var rawEdge=rawEdges[j];<span class="cstat-no" title="statement not covered" >v</span>ar sourceGuid=rawEdge.source;<span class="cstat-no" title="statement not covered" >v</span>ar sourceDump=allMemoryAllocatorDumpsByGuid[sourceGuid];<span class="cstat-no" title="statement not covered" >i</span>f(sourceDump===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Edge for PID='+pid+' and dump ID='+dumpId+' is missing source memory allocator dump (GUID='+sourceGuid+').'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar targetGuid=rawEdge.target;<span class="cstat-no" title="statement not covered" >v</span>ar targetDump=allMemoryAllocatorDumpsByGuid[targetGuid];<span class="cstat-no" title="statement not covered" >i</span>f(targetDump===undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Edge for PID='+pid+' and dump ID='+dumpId+' is missing target memory allocator dump (GUID='+targetGuid+').'});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar importance=rawEdge.importance;<span class="cstat-no" title="statement not covered" >v</span>ar edge=new tr.model.MemoryAllocatorDumpLink(sourceDump,targetDump,importance);<span class="cstat-no" title="statement not covered" >s</span>witch(rawEdge.type){case'ownership':<span class="cstat-no" title="statement not covered" >if(sourceDump.owns!==undefined){<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump '+sourceDump.fullName+' (GUID='+sourceGuid+') already owns a memory'+' allocator dump ('+sourceDump.owns.target.fullName+').'});}</span>else{<span class="cstat-no" title="statement not covered" >sourceDump.owns=edge;<span class="cstat-no" title="statement not covered" >t</span>argetDump.ownedBy.push(edge);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase'retention':<span class="cstat-no" title="statement not covered" >sourceDump.retains.push(edge);<span class="cstat-no" title="statement not covered" >t</span>argetDump.retainedBy.push(edge);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this.model_.importWarning({type:'memory_dump_parse_error',message:'Invalid edge type: '+rawEdge.type+' (PID='+pid+', dump ID='+dumpId+', source='+sourceGuid+', target='+targetGuid+', importance='+importance+').'});}</span>}</span>}</span>}</span>}</span>,toModelTimeFromUs_:<span class="fstat-no" title="function not covered" >function(ts){<span class="cstat-no" title="statement not covered" ></span>if(!this.toModelTime_){<span class="cstat-no" title="statement not covered" >this.toModelTime_=this.model_.clockSyncManager.getModelTimeTransformer(this.clockDomainId_);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.toModelTime_(tr.b.Unit.timestampFromUs(ts));}</span>,maybeToModelTimeFromUs_:<span class="fstat-no" title="function not covered" >function(ts){<span class="cstat-no" title="statement not covered" ></span>if(ts===undefined)<span class="cstat-no" title="statement not covered" >return undefined;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.toModelTimeFromUs_(ts);}</span>};tr.importer.Importer.register(TraceEventImporter);return{TraceEventImporter:TraceEventImporter};});
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 14:22:44 GMT+0000 (UTC)</div>
</div>
</body>
</html>
