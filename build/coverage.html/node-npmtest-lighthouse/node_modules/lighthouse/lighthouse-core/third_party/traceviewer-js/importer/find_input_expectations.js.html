<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/importer/find_input_expectations.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-lighthouse">npmtest-lighthouse (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/importer/find_input_expectations.js</span></h1>
    <h2>
        
        Statements: <span class="metric">12.59% <small>(69 / 548)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0% <small>(0 / 221)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">1.72% <small>(1 / 58)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(1 / 1)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/importer/</a> &#187; find_input_expectations.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2</td><td class="line-coverage"><span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";require("../base/range_utils.js");require("../extras/chrome/cc/input_latency_async_slice.js");require("./proto_expectation.js");'use strict';global.tr.exportTo('tr.importer',function(){var ProtoExpectation=tr.importer.ProtoExpectation;var INPUT_TYPE=tr.e.cc.INPUT_EVENT_TYPE_NAMES;var KEYBOARD_TYPE_NAMES=[INPUT_TYPE.CHAR,INPUT_TYPE.KEY_DOWN_RAW,INPUT_TYPE.KEY_DOWN,INPUT_TYPE.KEY_UP];var MOUSE_RESPONSE_TYPE_NAMES=[INPUT_TYPE.CLICK,INPUT_TYPE.CONTEXT_MENU];var MOUSE_WHEEL_TYPE_NAMES=[INPUT_TYPE.MOUSE_WHEEL];var MOUSE_DRAG_TYPE_NAMES=[INPUT_TYPE.MOUSE_DOWN,INPUT_TYPE.MOUSE_MOVE,INPUT_TYPE.MOUSE_UP];var TAP_TYPE_NAMES=[INPUT_TYPE.TAP,INPUT_TYPE.TAP_CANCEL,INPUT_TYPE.TAP_DOWN];var PINCH_TYPE_NAMES=[INPUT_TYPE.PINCH_BEGIN,INPUT_TYPE.PINCH_END,INPUT_TYPE.PINCH_UPDATE];var FLING_TYPE_NAMES=[INPUT_TYPE.FLING_CANCEL,INPUT_TYPE.FLING_START];var TOUCH_TYPE_NAMES=[INPUT_TYPE.TOUCH_END,INPUT_TYPE.TOUCH_MOVE,INPUT_TYPE.TOUCH_START];var SCROLL_TYPE_NAMES=[INPUT_TYPE.SCROLL_BEGIN,INPUT_TYPE.SCROLL_END,INPUT_TYPE.SCROLL_UPDATE];var ALL_HANDLED_TYPE_NAMES=[].concat(KEYBOARD_TYPE_NAMES,MOUSE_RESPONSE_TYPE_NAMES,MOUSE_WHEEL_TYPE_NAMES,MOUSE_DRAG_TYPE_NAMES,PINCH_TYPE_NAMES,TAP_TYPE_NAMES,FLING_TYPE_NAMES,TOUCH_TYPE_NAMES,SCROLL_TYPE_NAMES);var RENDERER_FLING_TITLE='InputHandlerProxy::HandleGestureFling::started';var PLAYBACK_EVENT_TITLE='VideoPlayback';var CSS_ANIMATION_TITLE='Animation';var INPUT_MERGE_THRESHOLD_MS=200;var ANIMATION_MERGE_THRESHOLD_MS=32;var MOUSE_WHEEL_THRESHOLD_MS=40;var MOUSE_MOVE_THRESHOLD_MS=40;var KEYBOARD_IR_NAME='Keyboard';var MOUSE_IR_NAME='Mouse';var MOUSEWHEEL_IR_NAME='MouseWheel';var TAP_IR_NAME='Tap';var PINCH_IR_NAME='Pinch';var FLING_IR_NAME='Fling';var TOUCH_IR_NAME='Touch';var SCROLL_IR_NAME='Scroll';var CSS_IR_NAME='CSS';var WEBGL_IR_NAME='WebGL';var VIDEO_IR_NAME='Video';<span class="fstat-no" title="function not covered" >function compareEvents(x,y){<span class="cstat-no" title="statement not covered" ></span>if(x.start!==y.start)<span class="cstat-no" title="statement not covered" >return x.start-y.start;<span class="cstat-no" title="statement not covered" >i</span></span>f(x.end!==y.end)<span class="cstat-no" title="statement not covered" >return x.end-y.end;<span class="cstat-no" title="statement not covered" >i</span></span>f(x.guid&amp;&amp;y.guid)<span class="cstat-no" title="statement not covered" >return x.guid-y.guid;<span class="cstat-no" title="statement not covered" >r</span></span>eturn 0;}<span class="fstat-no" title="function not covered" ></span>function forEventTypesIn(events,typeNames,cb,opt_this){<span class="cstat-no" title="statement not covered" ></span>events.forEach(<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(typeNames.indexOf(event.typeName)&gt;=0){<span class="cstat-no" title="statement not covered" >cb.call(opt_this,event);}</span>}</span>);}<span class="fstat-no" title="function not covered" ></span>function causedFrame(event){<span class="cstat-no" title="statement not covered" ></span>return event.associatedEvents.some(x=&gt;<span class="cstat-no" title="statement not covered" >x.title===tr.model.helpers.IMPL_RENDERING_STATS)</span>;}<span class="fstat-no" title="function not covered" ></span>function getSortedFrameEventsByProcess(modelHelper){<span class="cstat-no" title="statement not covered" ></span>var frameEventsByPid={};<span class="cstat-no" title="statement not covered" >t</span>r.b.iterItems(modelHelper.rendererHelpers,<span class="fstat-no" title="function not covered" >function(pid,rendererHelper){<span class="cstat-no" title="statement not covered" ></span>frameEventsByPid[pid]=rendererHelper.getFrameEventsInRange(tr.model.helpers.IMPL_FRAMETIME_TYPE,modelHelper.model.bounds);}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn frameEventsByPid;}<span class="fstat-no" title="function not covered" ></span>function getSortedInputEvents(modelHelper){<span class="cstat-no" title="statement not covered" ></span>var inputEvents=[];<span class="cstat-no" title="statement not covered" >v</span>ar browserProcess=modelHelper.browserHelper.process;<span class="cstat-no" title="statement not covered" >v</span>ar mainThread=browserProcess.findAtMostOneThreadNamed('CrBrowserMain');<span class="cstat-no" title="statement not covered" >f</span>or(var slice of mainThread.asyncSliceGroup.getDescendantEvents()){<span class="cstat-no" title="statement not covered" >if(!slice.isTopLevel)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(!(slice instanceof tr.e.cc.InputLatencyAsyncSlice))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(isNaN(slice.start)||isNaN(slice.duration)||isNaN(slice.end))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>nputEvents.push(slice);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn inputEvents.sort(compareEvents);}<span class="fstat-no" title="function not covered" ></span>function findProtoExpectations(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >v</span>ar handlers=[handleKeyboardEvents,handleMouseResponseEvents,handleMouseWheelEvents,handleMouseDragEvents,handleTapResponseEvents,handlePinchEvents,handleFlingEvents,handleTouchEvents,handleScrollEvents,handleCSSAnimations,handleWebGLAnimations,handleVideoAnimations];<span class="cstat-no" title="statement not covered" >h</span>andlers.forEach(<span class="fstat-no" title="function not covered" >function(handler){<span class="cstat-no" title="statement not covered" ></span>protoExpectations.push.apply(protoExpectations,handler(modelHelper,sortedInputEvents));}</span>);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.sort(compareEvents);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleKeyboardEvents(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >f</span>orEventTypesIn(sortedInputEvents,KEYBOARD_TYPE_NAMES,<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>var pe=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,KEYBOARD_IR_NAME);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleMouseResponseEvents(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >f</span>orEventTypesIn(sortedInputEvents,MOUSE_RESPONSE_TYPE_NAMES,<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>var pe=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,MOUSE_IR_NAME);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleMouseWheelEvents(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >v</span>ar currentPE=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar prevEvent_=undefined;<span class="cstat-no" title="statement not covered" >f</span>orEventTypesIn(sortedInputEvents,MOUSE_WHEEL_TYPE_NAMES,<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>var prevEvent=prevEvent_;<span class="cstat-no" title="statement not covered" >p</span>revEvent_=event;<span class="cstat-no" title="statement not covered" >i</span>f(currentPE&amp;&amp;prevEvent.start+MOUSE_WHEEL_THRESHOLD_MS&gt;=event.start){<span class="cstat-no" title="statement not covered" >if(currentPE.irType===ProtoExpectation.ANIMATION_TYPE){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,MOUSEWHEEL_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>c</span>urrentPE=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,MOUSEWHEEL_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleMouseDragEvents(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >v</span>ar currentPE=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar mouseDownEvent=undefined;<span class="cstat-no" title="statement not covered" >f</span>orEventTypesIn(sortedInputEvents,MOUSE_DRAG_TYPE_NAMES,<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>switch(event.typeName){case INPUT_TYPE.MOUSE_DOWN:<span class="cstat-no" title="statement not covered" >if(causedFrame(event)){<span class="cstat-no" title="statement not covered" >var pe=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,MOUSE_IR_NAME);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);}</span>else{<span class="cstat-no" title="statement not covered" >mouseDownEvent=event;}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase INPUT_TYPE.MOUSE_MOVE:<span class="cstat-no" title="statement not covered" >if(!causedFrame(event)){<span class="cstat-no" title="statement not covered" >var pe=new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);}</span>else <span class="cstat-no" title="statement not covered" >if(!currentPE||!currentPE.isNear(event,MOUSE_MOVE_THRESHOLD_MS)){<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,MOUSE_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >i</span>f(mouseDownEvent){<span class="cstat-no" title="statement not covered" >currentPE.associatedEvents.push(mouseDownEvent);<span class="cstat-no" title="statement not covered" >m</span>ouseDownEvent=undefined;}<span class="cstat-no" title="statement not covered" ></span>p</span>rotoExpectations.push(currentPE);}</span>else{<span class="cstat-no" title="statement not covered" >if(currentPE.irType===ProtoExpectation.ANIMATION_TYPE){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,MOUSE_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span></span>reak;c</span>ase INPUT_TYPE.MOUSE_UP:<span class="cstat-no" title="statement not covered" >if(!mouseDownEvent){<span class="cstat-no" title="statement not covered" >var pe=new ProtoExpectation(causedFrame(event)?ProtoExpectation.RESPONSE_TYPE:ProtoExpectation.IGNORED_TYPE,MOUSE_IR_NAME);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(currentPE){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,MOUSE_IR_NAME);<span class="cstat-no" title="statement not covered" >i</span>f(mouseDownEvent)<span class="cstat-no" title="statement not covered" >currentPE.associatedEvents.push(mouseDownEvent);<span class="cstat-no" title="statement not covered" >c</span></span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}<span class="cstat-no" title="statement not covered" ></span>m</span>ouseDownEvent=undefined;<span class="cstat-no" title="statement not covered" >c</span>urrentPE=undefined;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>);<span class="cstat-no" title="statement not covered" >i</span>f(mouseDownEvent){<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(mouseDownEvent);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleTapResponseEvents(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >v</span>ar currentPE=undefined;<span class="cstat-no" title="statement not covered" >f</span>orEventTypesIn(sortedInputEvents,TAP_TYPE_NAMES,<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>switch(event.typeName){case INPUT_TYPE.TAP_DOWN:<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,TAP_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase INPUT_TYPE.TAP:<span class="cstat-no" title="statement not covered" >if(currentPE){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,TAP_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}<span class="cstat-no" title="statement not covered" ></span>c</span>urrentPE=undefined;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase INPUT_TYPE.TAP_CANCEL:<span class="cstat-no" title="statement not covered" >if(!currentPE){<span class="cstat-no" title="statement not covered" >var pe=new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(currentPE.isNear(event,INPUT_MERGE_THRESHOLD_MS)){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,TAP_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}<span class="cstat-no" title="statement not covered" ></span>c</span>urrentPE=undefined;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handlePinchEvents(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >v</span>ar currentPE=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar sawFirstUpdate=false;<span class="cstat-no" title="statement not covered" >v</span>ar modelBounds=modelHelper.model.bounds;<span class="cstat-no" title="statement not covered" >f</span>orEventTypesIn(sortedInputEvents,PINCH_TYPE_NAMES,<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>switch(event.typeName){case INPUT_TYPE.PINCH_BEGIN:<span class="cstat-no" title="statement not covered" >if(currentPE&amp;&amp;currentPE.isNear(event,INPUT_MERGE_THRESHOLD_MS)){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>c</span>urrentPE=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,PINCH_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.isAnimationBegin=true;<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);<span class="cstat-no" title="statement not covered" >s</span>awFirstUpdate=false;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase INPUT_TYPE.PINCH_UPDATE:<span class="cstat-no" title="statement not covered" >if(!currentPE||currentPE.irType===ProtoExpectation.RESPONSE_TYPE&amp;&amp;sawFirstUpdate||!currentPE.isNear(event,INPUT_MERGE_THRESHOLD_MS)){<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,PINCH_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >s</span>awFirstUpdate=true;}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase INPUT_TYPE.PINCH_END:<span class="cstat-no" title="statement not covered" >if(currentPE){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >var pe=new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);}<span class="cstat-no" title="statement not covered" ></span>c</span>urrentPE=undefined;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleFlingEvents(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >v</span>ar currentPE=undefined;<span class="fstat-no" title="function not covered" >f</span>unction isRendererFling(event){<span class="cstat-no" title="statement not covered" ></span>return event.title===RENDERER_FLING_TITLE;}<span class="cstat-no" title="statement not covered" ></span>var browserHelper=modelHelper.browserHelper;<span class="cstat-no" title="statement not covered" >v</span>ar flingEvents=browserHelper.getAllAsyncSlicesMatching(isRendererFling);<span class="cstat-no" title="statement not covered" >f</span>orEventTypesIn(sortedInputEvents,FLING_TYPE_NAMES,<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>flingEvents.push(event);}</span>);<span class="cstat-no" title="statement not covered" >f</span>lingEvents.sort(compareEvents);<span class="cstat-no" title="statement not covered" >f</span>lingEvents.forEach(<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(event.title===RENDERER_FLING_TITLE){<span class="cstat-no" title="statement not covered" >if(currentPE){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,FLING_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(event.typeName){case INPUT_TYPE.FLING_START:<span class="cstat-no" title="statement not covered" >if(currentPE){<span class="cstat-no" title="statement not covered" >console.error('Another FlingStart? File a bug with this trace!');<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,FLING_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.end=0;<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase INPUT_TYPE.FLING_CANCEL:<span class="cstat-no" title="statement not covered" >if(currentPE){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.end=event.start;<span class="cstat-no" title="statement not covered" >c</span>urrentPE=undefined;}</span>else{<span class="cstat-no" title="statement not covered" >var pe=new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;}</span>}</span>);<span class="cstat-no" title="statement not covered" >i</span>f(currentPE&amp;&amp;!currentPE.end)<span class="cstat-no" title="statement not covered" >currentPE.end=modelHelper.model.bounds.max;<span class="cstat-no" title="statement not covered" >r</span></span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleTouchEvents(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >v</span>ar currentPE=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar sawFirstMove=false;<span class="cstat-no" title="statement not covered" >f</span>orEventTypesIn(sortedInputEvents,TOUCH_TYPE_NAMES,<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>switch(event.typeName){case INPUT_TYPE.TOUCH_START:<span class="cstat-no" title="statement not covered" >if(currentPE){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,TOUCH_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.isAnimationBegin=true;<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);<span class="cstat-no" title="statement not covered" >s</span>awFirstMove=false;}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase INPUT_TYPE.TOUCH_MOVE:<span class="cstat-no" title="statement not covered" >if(!currentPE){<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,TOUCH_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(sawFirstMove&amp;&amp;currentPE.irType===ProtoExpectation.RESPONSE_TYPE||!currentPE.isNear(event,INPUT_MERGE_THRESHOLD_MS)){<span class="cstat-no" title="statement not covered" >var prevEnd=currentPE.end;<span class="cstat-no" title="statement not covered" >c</span>urrentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,TOUCH_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.start=prevEnd;<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >s</span>awFirstMove=true;}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase INPUT_TYPE.TOUCH_END:<span class="cstat-no" title="statement not covered" >if(!currentPE){<span class="cstat-no" title="statement not covered" >var pe=new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(currentPE.isNear(event,INPUT_MERGE_THRESHOLD_MS)){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>else{<span class="cstat-no" title="statement not covered" >var pe=new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);}<span class="cstat-no" title="statement not covered" ></span>c</span>urrentPE=undefined;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleScrollEvents(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >v</span>ar currentPE=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar sawFirstUpdate=false;<span class="cstat-no" title="statement not covered" >f</span>orEventTypesIn(sortedInputEvents,SCROLL_TYPE_NAMES,<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>switch(event.typeName){case INPUT_TYPE.SCROLL_BEGIN:<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE,SCROLL_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.isAnimationBegin=true;<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);<span class="cstat-no" title="statement not covered" >s</span>awFirstUpdate=false;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase INPUT_TYPE.SCROLL_UPDATE:<span class="cstat-no" title="statement not covered" >if(currentPE){<span class="cstat-no" title="statement not covered" >if(currentPE.isNear(event,INPUT_MERGE_THRESHOLD_MS)&amp;&amp;(currentPE.irType===ProtoExpectation.ANIMATION_TYPE||!sawFirstUpdate)){<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >s</span>awFirstUpdate=true;}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,SCROLL_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}</span>}</span>else{<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,SCROLL_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase INPUT_TYPE.SCROLL_END:<span class="cstat-no" title="statement not covered" >if(!currentPE){<span class="cstat-no" title="statement not covered" >console.error('ScrollEnd without ScrollUpdate? '+'File a bug with this trace!');<span class="cstat-no" title="statement not covered" >v</span>ar pe=new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);<span class="cstat-no" title="statement not covered" >p</span>e.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(pe);<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleVideoAnimations(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var events=[];<span class="cstat-no" title="statement not covered" >f</span>or(var pid in modelHelper.rendererHelpers){<span class="cstat-no" title="statement not covered" >for(var asyncSlice of modelHelper.rendererHelpers[pid].mainThread.asyncSliceGroup.slices){<span class="cstat-no" title="statement not covered" >if(asyncSlice.title===PLAYBACK_EVENT_TITLE)<span class="cstat-no" title="statement not covered" >events.push(asyncSlice);}</span></span>}<span class="cstat-no" title="statement not covered" ></span>e</span>vents.sort(tr.importer.compareEvents);<span class="cstat-no" title="statement not covered" >v</span>ar protoExpectations=[];<span class="cstat-no" title="statement not covered" >f</span>or(var event of events){<span class="cstat-no" title="statement not covered" >var currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,VIDEO_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.start=event.start;<span class="cstat-no" title="statement not covered" >c</span>urrentPE.end=event.end;<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleCSSAnimations(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var animationEvents=modelHelper.browserHelper.getAllAsyncSlicesMatching(<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>return event.title===CSS_ANIMATION_TITLE&amp;&amp;event.isTopLevel&amp;&amp;event.duration&gt;0;}</span>);<span class="cstat-no" title="statement not covered" >v</span>ar animationRanges=[];<span class="fstat-no" title="function not covered" >f</span>unction pushAnimationRange(start,end,animation){<span class="cstat-no" title="statement not covered" ></span>var range=tr.b.Range.fromExplicitRange(start,end);<span class="cstat-no" title="statement not covered" >r</span>ange.animation=animation;<span class="cstat-no" title="statement not covered" >a</span>nimationRanges.push(range);}<span class="cstat-no" title="statement not covered" ></span>animationEvents.forEach(<span class="fstat-no" title="function not covered" >function(animation){<span class="cstat-no" title="statement not covered" ></span>if(animation.subSlices.length===0){<span class="cstat-no" title="statement not covered" >pushAnimationRange(animation.start,animation.end,animation);}</span>else{<span class="cstat-no" title="statement not covered" >var start=undefined;<span class="cstat-no" title="statement not covered" >a</span>nimation.subSlices.forEach(<span class="fstat-no" title="function not covered" >function(sub){<span class="cstat-no" title="statement not covered" ></span>if(sub.args.data.state==='running'&amp;&amp;start===undefined){<span class="cstat-no" title="statement not covered" >start=sub.start;}</span>else <span class="cstat-no" title="statement not covered" >if(sub.args.data.state==='paused'||sub.args.data.state==='idle'||sub.args.data.state==='finished'){<span class="cstat-no" title="statement not covered" >if(start===undefined){<span class="cstat-no" title="statement not covered" >start=modelHelper.model.bounds.min;}<span class="cstat-no" title="statement not covered" ></span>p</span>ushAnimationRange(start,sub.start,animation);<span class="cstat-no" title="statement not covered" >s</span>tart=undefined;}</span>}</span></span>);<span class="cstat-no" title="statement not covered" >i</span>f(start!==undefined)<span class="cstat-no" title="statement not covered" >pushAnimationRange(start,animation.end,animation);}</span></span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn animationRanges.map(<span class="fstat-no" title="function not covered" >function(range){<span class="cstat-no" title="statement not covered" ></span>var protoExpectation=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,CSS_IR_NAME);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectation.start=range.min;<span class="cstat-no" title="statement not covered" >p</span>rotoExpectation.end=range.max;<span class="cstat-no" title="statement not covered" >p</span>rotoExpectation.associatedEvents.push(range.animation);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectation;}</span>);}<span class="fstat-no" title="function not covered" ></span>function findWebGLEvents(modelHelper,mailboxEvents,animationEvents){<span class="cstat-no" title="statement not covered" ></span>for(var event of modelHelper.model.getDescendantEvents()){<span class="cstat-no" title="statement not covered" >if(event.title==='DrawingBuffer::prepareMailbox')<span class="cstat-no" title="statement not covered" >mailboxEvents.push(event);e</span>lse <span class="cstat-no" title="statement not covered" >if(event.title==='PageAnimator::serviceScriptedAnimations')<span class="cstat-no" title="statement not covered" >animationEvents.push(event);}</span></span></span>}<span class="fstat-no" title="function not covered" ></span>function findMailboxEventsNearAnimationEvents(mailboxEvents,animationEvents){<span class="cstat-no" title="statement not covered" ></span>if(animationEvents.length===0)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >m</span></span>ailboxEvents.sort(compareEvents);<span class="cstat-no" title="statement not covered" >a</span>nimationEvents.sort(compareEvents);<span class="cstat-no" title="statement not covered" >v</span>ar animationIterator=animationEvents[Symbol.iterator]();<span class="cstat-no" title="statement not covered" >v</span>ar animationEvent=animationIterator.next().value;<span class="cstat-no" title="statement not covered" >v</span>ar filteredEvents=[];<span class="cstat-no" title="statement not covered" >f</span>or(var event of mailboxEvents){<span class="cstat-no" title="statement not covered" >while(animationEvent&amp;&amp;animationEvent.start&lt;event.start-ANIMATION_MERGE_THRESHOLD_MS)<span class="cstat-no" title="statement not covered" >animationEvent=animationIterator.next().value;<span class="cstat-no" title="statement not covered" >i</span></span>f(!animationEvent)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(animationEvent.start&lt;event.start+ANIMATION_MERGE_THRESHOLD_MS)<span class="cstat-no" title="statement not covered" >filteredEvents.push(event);}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn filteredEvents;}<span class="fstat-no" title="function not covered" ></span>function createProtoExpectationsFromMailboxEvents(mailboxEvents){<span class="cstat-no" title="statement not covered" ></span>var protoExpectations=[];<span class="cstat-no" title="statement not covered" >v</span>ar currentPE=undefined;<span class="cstat-no" title="statement not covered" >f</span>or(var event of mailboxEvents){<span class="cstat-no" title="statement not covered" >if(currentPE===undefined||!currentPE.isNear(event,ANIMATION_MERGE_THRESHOLD_MS)){<span class="cstat-no" title="statement not covered" >currentPE=new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,WEBGL_IR_NAME);<span class="cstat-no" title="statement not covered" >c</span>urrentPE.pushEvent(event);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.push(currentPE);}</span>else{<span class="cstat-no" title="statement not covered" >currentPE.pushEvent(event);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function handleWebGLAnimations(modelHelper,sortedInputEvents){<span class="cstat-no" title="statement not covered" ></span>var prepareMailboxEvents=[];<span class="cstat-no" title="statement not covered" >v</span>ar scriptedAnimationEvents=[];<span class="cstat-no" title="statement not covered" >f</span>indWebGLEvents(modelHelper,prepareMailboxEvents,scriptedAnimationEvents);<span class="cstat-no" title="statement not covered" >v</span>ar webGLMailboxEvents=findMailboxEventsNearAnimationEvents(prepareMailboxEvents,scriptedAnimationEvents);<span class="cstat-no" title="statement not covered" >r</span>eturn createProtoExpectationsFromMailboxEvents(webGLMailboxEvents);}<span class="fstat-no" title="function not covered" ></span>function postProcessProtoExpectations(modelHelper,protoExpectations){<span class="cstat-no" title="statement not covered" ></span>protoExpectations=findFrameEventsForAnimations(modelHelper,protoExpectations);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations=mergeIntersectingResponses(protoExpectations);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations=mergeIntersectingAnimations(protoExpectations);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations=fixResponseAnimationStarts(protoExpectations);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations=fixTapResponseTouchAnimations(protoExpectations);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function mergeIntersectingResponses(protoExpectations){<span class="cstat-no" title="statement not covered" ></span>var newPEs=[];<span class="cstat-no" title="statement not covered" >w</span>hile(protoExpectations.length){<span class="cstat-no" title="statement not covered" >var pe=protoExpectations.shift();<span class="cstat-no" title="statement not covered" >n</span>ewPEs.push(pe);<span class="cstat-no" title="statement not covered" >i</span>f(pe.irType!==ProtoExpectation.RESPONSE_TYPE)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=0;i&lt;protoExpectations.length;++i){<span class="cstat-no" title="statement not covered" >var otherPE=protoExpectations[i];<span class="cstat-no" title="statement not covered" >i</span>f(otherPE.irType!==pe.irType)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(!otherPE.intersects(pe))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar typeNames=pe.associatedEvents.map(<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>return event.typeName;}</span>);<span class="cstat-no" title="statement not covered" >i</span>f(otherPE.containsTypeNames(typeNames))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >p</span></span>e.merge(otherPE);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.splice(i,1);<span class="cstat-no" title="statement not covered" >-</span>-i;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn newPEs;}<span class="fstat-no" title="function not covered" ></span>function mergeIntersectingAnimations(protoExpectations){<span class="cstat-no" title="statement not covered" ></span>var newPEs=[];<span class="cstat-no" title="statement not covered" >w</span>hile(protoExpectations.length){<span class="cstat-no" title="statement not covered" >var pe=protoExpectations.shift();<span class="cstat-no" title="statement not covered" >n</span>ewPEs.push(pe);<span class="cstat-no" title="statement not covered" >i</span>f(pe.irType!==ProtoExpectation.ANIMATION_TYPE)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar isCSS=pe.containsSliceTitle(CSS_ANIMATION_TITLE);<span class="cstat-no" title="statement not covered" >v</span>ar isFling=pe.containsTypeNames([INPUT_TYPE.FLING_START]);<span class="cstat-no" title="statement not covered" >v</span>ar isVideo=pe.containsTypeNames([VIDEO_IR_NAME]);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;protoExpectations.length;++i){<span class="cstat-no" title="statement not covered" >var otherPE=protoExpectations[i];<span class="cstat-no" title="statement not covered" >i</span>f(otherPE.irType!==pe.irType)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(isCSS!=otherPE.containsSliceTitle(CSS_ANIMATION_TITLE))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(isCSS){<span class="cstat-no" title="statement not covered" >if(!pe.isNear(otherPE,ANIMATION_MERGE_THRESHOLD_MS))<span class="cstat-no" title="statement not covered" >continue;}</span></span>else <span class="cstat-no" title="statement not covered" >if(!otherPE.intersects(pe)){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(isFling!==otherPE.containsTypeNames([INPUT_TYPE.FLING_START]))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(isVideo!==otherPE.containsTypeNames([VIDEO_IR_NAME]))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >p</span></span>e.merge(otherPE);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.splice(i,1);<span class="cstat-no" title="statement not covered" >-</span>-i;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn newPEs;}<span class="fstat-no" title="function not covered" ></span>function fixResponseAnimationStarts(protoExpectations){<span class="cstat-no" title="statement not covered" ></span>protoExpectations.forEach(<span class="fstat-no" title="function not covered" >function(ape){<span class="cstat-no" title="statement not covered" ></span>if(ape.irType!==ProtoExpectation.ANIMATION_TYPE)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >p</span></span>rotoExpectations.forEach(<span class="fstat-no" title="function not covered" >function(rpe){<span class="cstat-no" title="statement not covered" ></span>if(rpe.irType!==ProtoExpectation.RESPONSE_TYPE)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!ape.containsTimestampInclusive(rpe.end))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(ape.containsTimestampInclusive(rpe.start))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >a</span></span>pe.start=rpe.end;}</span>);}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn protoExpectations;}<span class="fstat-no" title="function not covered" ></span>function fixTapResponseTouchAnimations(protoExpectations){<span class="fstat-no" title="function not covered" ></span>function isTapResponse(pe){<span class="cstat-no" title="statement not covered" ></span>return pe.irType===ProtoExpectation.RESPONSE_TYPE&amp;&amp;pe.containsTypeNames([INPUT_TYPE.TAP]);}<span class="fstat-no" title="function not covered" ></span>function isTouchAnimation(pe){<span class="cstat-no" title="statement not covered" ></span>return pe.irType===ProtoExpectation.ANIMATION_TYPE&amp;&amp;pe.containsTypeNames([INPUT_TYPE.TOUCH_MOVE])&amp;&amp;!pe.containsTypeNames([INPUT_TYPE.SCROLL_UPDATE,INPUT_TYPE.PINCH_UPDATE]);}<span class="cstat-no" title="statement not covered" ></span>var newPEs=[];<span class="cstat-no" title="statement not covered" >w</span>hile(protoExpectations.length){<span class="cstat-no" title="statement not covered" >var pe=protoExpectations.shift();<span class="cstat-no" title="statement not covered" >n</span>ewPEs.push(pe);<span class="cstat-no" title="statement not covered" >v</span>ar peIsTapResponse=isTapResponse(pe);<span class="cstat-no" title="statement not covered" >v</span>ar peIsTouchAnimation=isTouchAnimation(pe);<span class="cstat-no" title="statement not covered" >i</span>f(!peIsTapResponse&amp;&amp;!peIsTouchAnimation)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=0;i&lt;protoExpectations.length;++i){<span class="cstat-no" title="statement not covered" >var otherPE=protoExpectations[i];<span class="cstat-no" title="statement not covered" >i</span>f(!otherPE.intersects(pe))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(peIsTapResponse&amp;&amp;!isTouchAnimation(otherPE))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(peIsTouchAnimation&amp;&amp;!isTapResponse(otherPE))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >p</span></span>e.irType=ProtoExpectation.RESPONSE_TYPE;<span class="cstat-no" title="statement not covered" >p</span>e.merge(otherPE);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.splice(i,1);<span class="cstat-no" title="statement not covered" >-</span>-i;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn newPEs;}<span class="fstat-no" title="function not covered" ></span>function findFrameEventsForAnimations(modelHelper,protoExpectations){<span class="cstat-no" title="statement not covered" ></span>var newPEs=[];<span class="cstat-no" title="statement not covered" >v</span>ar frameEventsByPid=getSortedFrameEventsByProcess(modelHelper);<span class="cstat-no" title="statement not covered" >f</span>or(var pe of protoExpectations){<span class="cstat-no" title="statement not covered" >if(pe.irType!==ProtoExpectation.ANIMATION_TYPE){<span class="cstat-no" title="statement not covered" >newPEs.push(pe);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar frameEvents=[];<span class="cstat-no" title="statement not covered" >f</span>or(var pid of Object.keys(modelHelper.rendererHelpers)){<span class="cstat-no" title="statement not covered" >var range=tr.b.Range.fromExplicitRange(pe.start,pe.end);<span class="cstat-no" title="statement not covered" >f</span>rameEvents.push.apply(frameEvents,range.filterArray(frameEventsByPid[pid],e=&gt;<span class="cstat-no" title="statement not covered" >e.start)</span>);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(frameEvents.length===0&amp;&amp;!pe.names.has(WEBGL_IR_NAME)){<span class="cstat-no" title="statement not covered" >pe.irType=ProtoExpectation.IGNORED_TYPE;<span class="cstat-no" title="statement not covered" >n</span>ewPEs.push(pe);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>p</span>e.associatedEvents.addEventSet(frameEvents);<span class="cstat-no" title="statement not covered" >n</span>ewPEs.push(pe);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn newPEs;}<span class="fstat-no" title="function not covered" ></span>function checkAllInputEventsHandled(sortedInputEvents,protoExpectations){<span class="cstat-no" title="statement not covered" ></span>var handledEvents=[];<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.forEach(<span class="fstat-no" title="function not covered" >function(protoExpectation){<span class="cstat-no" title="statement not covered" ></span>protoExpectation.associatedEvents.forEach(<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(event.title===CSS_ANIMATION_TITLE&amp;&amp;event.subSlices.length&gt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(handledEvents.indexOf(event)&gt;=0&amp;&amp;event.title!==tr.model.helpers.IMPL_RENDERING_STATS){<span class="cstat-no" title="statement not covered" >console.error('double-handled event',event.typeName,parseInt(event.start),parseInt(event.end),protoExpectation);<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>h</span>andledEvents.push(event);}</span>);}</span>);<span class="cstat-no" title="statement not covered" >s</span>ortedInputEvents.forEach(<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>if(handledEvents.indexOf(event)&lt;0){<span class="cstat-no" title="statement not covered" >console.error('UNHANDLED INPUT EVENT!',event.typeName,parseInt(event.start),parseInt(event.end));}</span>}</span>);}<span class="fstat-no" title="function not covered" ></span>function findInputExpectations(modelHelper){<span class="cstat-no" title="statement not covered" ></span>var sortedInputEvents=getSortedInputEvents(modelHelper);<span class="cstat-no" title="statement not covered" >v</span>ar protoExpectations=findProtoExpectations(modelHelper,sortedInputEvents);<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations=postProcessProtoExpectations(modelHelper,protoExpectations);<span class="cstat-no" title="statement not covered" >c</span>heckAllInputEventsHandled(sortedInputEvents,protoExpectations);<span class="cstat-no" title="statement not covered" >v</span>ar irs=[];<span class="cstat-no" title="statement not covered" >p</span>rotoExpectations.forEach(<span class="fstat-no" title="function not covered" >function(protoExpectation){<span class="cstat-no" title="statement not covered" ></span>var ir=protoExpectation.createInteractionRecord(modelHelper.model);<span class="cstat-no" title="statement not covered" >i</span>f(ir)<span class="cstat-no" title="statement not covered" >irs.push(ir);}</span></span>);<span class="cstat-no" title="statement not covered" >r</span>eturn irs;}</span>return{findInputExpectations:findInputExpectations,compareEvents:compareEvents,CSS_ANIMATION_TITLE:CSS_ANIMATION_TITLE};});
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 14:21:24 GMT+0000 (UTC)</div>
</div>
</body>
</html>
