<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/value/histogram.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-lighthouse">npmtest-lighthouse (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/value/histogram.js</span></h1>
    <h2>
        
        Statements: <span class="metric">13.33% <small>(54 / 405)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">3.19% <small>(6 / 188)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">16.36% <small>(9 / 55)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(1 / 1)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/value/</a> &#187; histogram.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2</td><td class="line-coverage"><span class="cline-any cline-yes">60</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";var _slicedToArray=function(){<span class="fstat-no" title="function not covered" >function sliceIterator(arr,i){<span class="cstat-no" title="statement not covered" ></span>var _arr=[];<span class="cstat-no" title="statement not covered" >v</span>ar _n=true;<span class="cstat-no" title="statement not covered" >v</span>ar _d=false;<span class="cstat-no" title="statement not covered" >v</span>ar _e=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){<span class="cstat-no" title="statement not covered" >_arr.push(_s.value);<span class="cstat-no" title="statement not covered" >i</span>f(i&amp;&amp;_arr.length===i)<span class="cstat-no" title="statement not covered" >break;}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_d=true;<span class="cstat-no" title="statement not covered" >_</span>e=err;}</span>finally{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_n&amp;&amp;_i["return"])<span class="cstat-no" title="statement not covered" >_i["return"]();}</span></span>finally{<span class="cstat-no" title="statement not covered" >if(_d)<span class="cstat-no" title="statement not covered" >throw _e;}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _arr;}</span>return <span class="fstat-no" title="function not covered" >function(arr,i){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(arr)){<span class="cstat-no" title="statement not covered" >return arr;}</span>else <span class="cstat-no" title="statement not covered" >if(Symbol.iterator in Object(arr)){<span class="cstat-no" title="statement not covered" >return sliceIterator(arr,i);}</span>else{<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to destructure non-iterable instance");}</span>}</span></span>;}();require("../base/iteration_helpers.js");require("../base/range.js");require("../base/running_statistics.js");require("../base/sorted_array_utils.js");require("../base/statistics.js");require("../base/unit.js");require("./diagnostics/diagnostic_map.js");require("./numeric.js");'use strict';global.tr.exportTo('tr.v',function(){var MAX_DIAGNOSTIC_MAPS=16;var DEFAULT_BOUNDARIES_FOR_UNIT=new Map();class HistogramBin{constructor<span class="fstat-no" title="function not covered" >(range){<span class="cstat-no" title="statement not covered" ></span>this.range=range;<span class="cstat-no" title="statement not covered" >t</span>his.count=0;<span class="cstat-no" title="statement not covered" >t</span>his.diagnosticMaps=[];}</span>addSample<span class="fstat-no" title="function not covered" >(value){<span class="cstat-no" title="statement not covered" ></span>this.count+=1;}</span>addDiagnosticMap<span class="fstat-no" title="function not covered" >(diagnostics){<span class="cstat-no" title="statement not covered" ></span>tr.b.Statistics.uniformlySampleStream(this.diagnosticMaps,this.count,diagnostics,MAX_DIAGNOSTIC_MAPS);}</span>addBin<span class="fstat-no" title="function not covered" >(other){<span class="cstat-no" title="statement not covered" ></span>if(!this.range.equals(other.range))<span class="cstat-no" title="statement not covered" >throw new Error('Merging incompatible Histogram bins.');<span class="cstat-no" title="statement not covered" >t</span></span>r.b.Statistics.mergeSampledStreams(this.diagnosticMaps,this.count,other.diagnosticMaps,other.count,MAX_DIAGNOSTIC_MAPS);<span class="cstat-no" title="statement not covered" >t</span>his.count+=other.count;}</span>fromDict<span class="fstat-no" title="function not covered" >(dict){<span class="cstat-no" title="statement not covered" ></span>this.count=dict[0];<span class="cstat-no" title="statement not covered" >i</span>f(dict.length&gt;1){<span class="cstat-no" title="statement not covered" >for(var map of dict[1]){<span class="cstat-no" title="statement not covered" >this.diagnosticMaps.push(tr.v.d.DiagnosticMap.fromDict(map));}</span>}</span>}</span>asDict<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>if(!this.diagnosticMaps.length){<span class="cstat-no" title="statement not covered" >return[this.count];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[this.count,this.diagnosticMaps.map(d=&gt;<span class="cstat-no" title="statement not covered" >d.asDict())</span>];}</span>}var DEFAULT_SUMMARY_OPTIONS=new Map([['avg',true],['geometricMean',false],['std',true],['count',true],['sum',true],['min',true],['max',true],['nans',false]]);class Histogram{constructor<span class="fstat-no" title="function not covered" >(name,unit,opt_binBoundaries){<span class="cstat-no" title="statement not covered" ></span>var binBoundaries=opt_binBoundaries;<span class="cstat-no" title="statement not covered" >i</span>f(!binBoundaries){<span class="cstat-no" title="statement not covered" >var baseUnit=unit.baseUnit?unit.baseUnit:unit;<span class="cstat-no" title="statement not covered" >b</span>inBoundaries=DEFAULT_BOUNDARIES_FOR_UNIT.get(baseUnit.unitName);}<span class="cstat-no" title="statement not covered" ></span>t</span>his.guid_=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.binBoundariesDict_=binBoundaries.asDict();<span class="cstat-no" title="statement not covered" >t</span>his.centralBins=[];<span class="cstat-no" title="statement not covered" >t</span>his.description='';<span class="cstat-no" title="statement not covered" >t</span>his.diagnostics=new tr.v.d.DiagnosticMap();<span class="cstat-no" title="statement not covered" >t</span>his.maxCount_=0;<span class="cstat-no" title="statement not covered" >t</span>his.name_=name;<span class="cstat-no" title="statement not covered" >t</span>his.nanDiagnosticMaps=[];<span class="cstat-no" title="statement not covered" >t</span>his.numNans=0;<span class="cstat-no" title="statement not covered" >t</span>his.running=new tr.b.RunningStatistics();<span class="cstat-no" title="statement not covered" >t</span>his.sampleValues_=[];<span class="cstat-no" title="statement not covered" >t</span>his.shortName=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.summaryOptions=new Map(DEFAULT_SUMMARY_OPTIONS);<span class="cstat-no" title="statement not covered" >t</span>his.summaryOptions.set('percentile',[]);<span class="cstat-no" title="statement not covered" >t</span>his.unit=unit;<span class="cstat-no" title="statement not covered" >t</span>his.underflowBin=new HistogramBin(tr.b.Range.fromExplicitRange(-Number.MAX_VALUE,binBoundaries.range.min));<span class="cstat-no" title="statement not covered" >t</span>his.overflowBin=new HistogramBin(tr.b.Range.fromExplicitRange(binBoundaries.range.max,Number.MAX_VALUE));<span class="cstat-no" title="statement not covered" >f</span>or(var range of binBoundaries.binRanges()){<span class="cstat-no" title="statement not covered" >this.centralBins.push(new HistogramBin(range));}<span class="cstat-no" title="statement not covered" ></span>t</span>his.allBins=[this.underflowBin];<span class="cstat-no" title="statement not covered" >f</span>or(var bin of this.centralBins)<span class="cstat-no" title="statement not covered" >this.allBins.push(bin);<span class="cstat-no" title="statement not covered" >t</span></span>his.allBins.push(this.overflowBin);<span class="cstat-no" title="statement not covered" >t</span>his.maxNumSampleValues_=this.defaultMaxNumSampleValues_;}</span>get maxNumSampleValues<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.maxNumSampleValues_;}</span>set maxNumSampleValues<span class="fstat-no" title="function not covered" >(n){<span class="cstat-no" title="statement not covered" ></span>this.maxNumSampleValues_=n;<span class="cstat-no" title="statement not covered" >t</span>r.b.Statistics.uniformlySampleArray(this.sampleValues_,this.maxNumSampleValues_);}</span>get name<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.name_;}</span>get guid<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>if(this.guid_===undefined)<span class="cstat-no" title="statement not covered" >this.guid_=tr.b.GUID.allocateUUID4();<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.guid_;}</span>set guid<span class="fstat-no" title="function not covered" >(guid){<span class="cstat-no" title="statement not covered" ></span>if(this.guid_!==undefined)<span class="cstat-no" title="statement not covered" >throw new Error('Cannot reset guid');<span class="cstat-no" title="statement not covered" >t</span></span>his.guid_=guid;}</span>static fromDict<span class="fstat-no" title="function not covered" >(dict){<span class="cstat-no" title="statement not covered" ></span>var hist=new Histogram(dict.name,tr.b.Unit.fromJSON(dict.unit),HistogramBinBoundaries.fromDict(dict.binBoundaries));<span class="cstat-no" title="statement not covered" >h</span>ist.guid=dict.guid;<span class="cstat-no" title="statement not covered" >i</span>f(dict.shortName){<span class="cstat-no" title="statement not covered" >hist.shortName=dict.shortName;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.description){<span class="cstat-no" title="statement not covered" >hist.description=dict.description;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.diagnostics){<span class="cstat-no" title="statement not covered" >hist.diagnostics.addDicts(dict.diagnostics);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.underflowBin){<span class="cstat-no" title="statement not covered" >hist.underflowBin.fromDict(dict.underflowBin);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.overflowBin){<span class="cstat-no" title="statement not covered" >hist.overflowBin.fromDict(dict.overflowBin);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.centralBins){<span class="cstat-no" title="statement not covered" >if(dict.centralBins.length!==undefined){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;dict.centralBins.length;++i){<span class="cstat-no" title="statement not covered" >hist.centralBins[i].fromDict(dict.centralBins[i]);}</span>}</span>else{<span class="cstat-no" title="statement not covered" >tr.b.iterItems(dict.centralBins,(i,binDict)=&gt;{<span class="cstat-no" title="statement not covered" >hist.centralBins[i].fromDict(binDict);}</span>);}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var bin of hist.allBins){<span class="cstat-no" title="statement not covered" >hist.maxCount_=Math.max(hist.maxCount_,bin.count);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.running){<span class="cstat-no" title="statement not covered" >hist.running=tr.b.RunningStatistics.fromDict(dict.running);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.summaryOptions){<span class="cstat-no" title="statement not covered" >hist.customizeSummaryOptions(dict.summaryOptions);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.maxNumSampleValues!==undefined){<span class="cstat-no" title="statement not covered" >hist.maxNumSampleValues=dict.maxNumSampleValues;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.sampleValues){<span class="cstat-no" title="statement not covered" >hist.sampleValues_=dict.sampleValues;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.numNans){<span class="cstat-no" title="statement not covered" >hist.numNans=dict.numNans;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dict.nanDiagnostics){<span class="cstat-no" title="statement not covered" >for(var map of dict.nanDiagnostics){<span class="cstat-no" title="statement not covered" >hist.nanDiagnosticMaps.push(tr.v.d.DiagnosticMap.fromDict(map));}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn hist;}</span>static buildFromSamples<span class="fstat-no" title="function not covered" >(unit,samples){<span class="cstat-no" title="statement not covered" ></span>var boundaries=HistogramBinBoundaries.createFromSamples(samples);<span class="cstat-no" title="statement not covered" >v</span>ar result=new Histogram(unit,boundaries);<span class="cstat-no" title="statement not covered" >r</span>esult.maxNumSampleValues=1000;<span class="cstat-no" title="statement not covered" >f</span>or(var sample of samples)<span class="cstat-no" title="statement not covered" >result.addSample(sample);<span class="cstat-no" title="statement not covered" >r</span></span>eturn result;}</span>get numValues<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return tr.b.Statistics.sum(this.allBins,<span class="fstat-no" title="function not covered" >function(e){<span class="cstat-no" title="statement not covered" ></span>return e.count;}</span>);}</span>get average<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.running.mean;}</span>get standardDeviation<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.running.stddev;}</span>get geometricMean<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.running.geometricMean;}</span>get sum<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.running.sum;}</span>get maxCount<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.maxCount_;}</span>getDifferenceSignificance<span class="fstat-no" title="function not covered" >(other,opt_alpha){<span class="cstat-no" title="statement not covered" ></span>if(this.unit!==other.unit)<span class="cstat-no" title="statement not covered" >throw new Error('Cannot compare Numerics with different units');<span class="cstat-no" title="statement not covered" >i</span></span>f(this.unit.improvementDirection===tr.b.ImprovementDirection.DONT_CARE){<span class="cstat-no" title="statement not covered" >return tr.b.Statistics.Significance.DONT_CARE;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(other instanceof Histogram))<span class="cstat-no" title="statement not covered" >throw new Error('Unable to compute a p-value');<span class="cstat-no" title="statement not covered" >v</span></span>ar testResult=tr.b.Statistics.mwu(this.sampleValues,other.sampleValues,opt_alpha);<span class="cstat-no" title="statement not covered" >r</span>eturn testResult.significance;}</span>getApproximatePercentile<span class="fstat-no" title="function not covered" >(percent){<span class="cstat-no" title="statement not covered" ></span>if(!(percent&gt;=0&amp;&amp;percent&lt;=1))<span class="cstat-no" title="statement not covered" >throw new Error('percent must be [0,1]');<span class="cstat-no" title="statement not covered" >i</span></span>f(this.numValues==0)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >v</span></span>ar valuesToSkip=Math.floor((this.numValues-1)*percent);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;this.allBins.length;i++){<span class="cstat-no" title="statement not covered" >var bin=this.allBins[i];<span class="cstat-no" title="statement not covered" >v</span>aluesToSkip-=bin.count;<span class="cstat-no" title="statement not covered" >i</span>f(valuesToSkip&lt;0){<span class="cstat-no" title="statement not covered" >if(bin===this.underflowBin)<span class="cstat-no" title="statement not covered" >return bin.range.max;e</span>lse <span class="cstat-no" title="statement not covered" >if(bin===this.overflowBin)<span class="cstat-no" title="statement not covered" >return bin.range.min;e</span>lse <span class="cstat-no" title="statement not covered" >return bin.range.center;}</span></span></span>}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new Error('Unreachable');}</span>getBinForValue<span class="fstat-no" title="function not covered" >(value){<span class="cstat-no" title="statement not covered" ></span>var binIndex=tr.b.findHighIndexInSortedArray(this.allBins,b=&gt;<span class="cstat-no" title="statement not covered" >value&lt;b.range.max?-1:1)</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn this.allBins[binIndex]||this.overflowBin;}</span>addSample<span class="fstat-no" title="function not covered" >(value,opt_diagnostics){<span class="cstat-no" title="statement not covered" ></span>if(opt_diagnostics&amp;&amp;!(opt_diagnostics instanceof tr.v.d.DiagnosticMap))<span class="cstat-no" title="statement not covered" >opt_diagnostics=tr.v.d.DiagnosticMap.fromObject(opt_diagnostics);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof value!=='number'||isNaN(value)){<span class="cstat-no" title="statement not covered" >this.numNans++;<span class="cstat-no" title="statement not covered" >i</span>f(opt_diagnostics){<span class="cstat-no" title="statement not covered" >tr.b.Statistics.uniformlySampleStream(this.nanDiagnosticMaps,this.numNans,opt_diagnostics,MAX_DIAGNOSTIC_MAPS);}</span>}</span>else{<span class="cstat-no" title="statement not covered" >this.running.add(value);<span class="cstat-no" title="statement not covered" >v</span>ar bin=this.getBinForValue(value);<span class="cstat-no" title="statement not covered" >b</span>in.addSample(value);<span class="cstat-no" title="statement not covered" >i</span>f(opt_diagnostics)<span class="cstat-no" title="statement not covered" >bin.addDiagnosticMap(opt_diagnostics);<span class="cstat-no" title="statement not covered" >i</span></span>f(bin.count&gt;this.maxCount_)<span class="cstat-no" title="statement not covered" >this.maxCount_=bin.count;}<span class="cstat-no" title="statement not covered" ></span></span>t</span>r.b.Statistics.uniformlySampleStream(this.sampleValues_,this.numValues+this.numNans,value,this.maxNumSampleValues);}</span>sampleValuesInto<span class="fstat-no" title="function not covered" >(samples){<span class="cstat-no" title="statement not covered" ></span>for(var sampleValue of this.sampleValues)<span class="cstat-no" title="statement not covered" >samples.push(sampleValue);}</span></span>canAddHistogram<span class="fstat-no" title="function not covered" >(other){<span class="cstat-no" title="statement not covered" ></span>if(this.unit!==other.unit)<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.allBins.length!==other.allBins.length)<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=0;i&lt;this.allBins.length;++i)<span class="cstat-no" title="statement not covered" >if(!this.allBins[i].range.equals(other.allBins[i].range))<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn true;}</span>addHistogram<span class="fstat-no" title="function not covered" >(other){<span class="cstat-no" title="statement not covered" ></span>if(!this.canAddHistogram(other)){<span class="cstat-no" title="statement not covered" >throw new Error('Merging incompatible Histograms');}<span class="cstat-no" title="statement not covered" ></span>t</span>r.b.Statistics.mergeSampledStreams(this.nanDiagnosticMaps,this.numNans,other.nanDiagnosticMaps,other.numNans,MAX_DIAGNOSTIC_MAPS);<span class="cstat-no" title="statement not covered" >t</span>r.b.Statistics.mergeSampledStreams(this.sampleValues,this.numValues,other.sampleValues,other.numValues,tr.b.Statistics.mean([this.maxNumSampleValues,other.maxNumSampleValues]));<span class="cstat-no" title="statement not covered" >t</span>his.numNans+=other.numNans;<span class="cstat-no" title="statement not covered" >t</span>his.running=this.running.merge(other.running);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;this.allBins.length;++i){<span class="cstat-no" title="statement not covered" >this.allBins[i].addBin(other.allBins[i]);}</span>}</span>customizeSummaryOptions<span class="fstat-no" title="function not covered" >(summaryOptions){<span class="cstat-no" title="statement not covered" ></span>tr.b.iterItems(summaryOptions,(key,value)=&gt;<span class="cstat-no" title="statement not covered" >this.summaryOptions.set(key,value))</span>;}</span>get statisticsScalars<span class="fstat-no" title="function not covered" >(){<span class="fstat-no" title="function not covered" ></span>function statNameToKey(stat){<span class="cstat-no" title="statement not covered" ></span>switch(stat){case'std':<span class="cstat-no" title="statement not covered" >return'stddev';c</span>ase'avg':<span class="cstat-no" title="statement not covered" >return'mean';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn stat;}<span class="fstat-no" title="function not covered" ></span>function percentToString(percent){<span class="cstat-no" title="statement not covered" ></span>if(percent&lt;0||percent&gt;1)<span class="cstat-no" title="statement not covered" >throw new Error('Percent must be between 0.0 and 1.0');<span class="cstat-no" title="statement not covered" >s</span></span>witch(percent){case 0:<span class="cstat-no" title="statement not covered" >return'000';c</span>ase 1:<span class="cstat-no" title="statement not covered" >return'100';}<span class="cstat-no" title="statement not covered" ></span>v</span>ar str=percent.toString();<span class="cstat-no" title="statement not covered" >i</span>f(str[1]!=='.')<span class="cstat-no" title="statement not covered" >throw new Error('Unexpected percent');<span class="cstat-no" title="statement not covered" >s</span></span>tr=str+'0'.repeat(Math.max(4-str.length,0));<span class="cstat-no" title="statement not covered" >i</span>f(str.length&gt;4)<span class="cstat-no" title="statement not covered" >str=str.slice(0,4)+'_'+str.slice(4);<span class="cstat-no" title="statement not covered" >r</span></span>eturn'0'+str.slice(2);}<span class="cstat-no" title="statement not covered" ></span>var results=new Map();<span class="cstat-no" title="statement not covered" >f</span>or(var _ref of this.summaryOptions){<span class="cstat-no" title="statement not covered" >var _ref2=_slicedToArray(_ref,2);<span class="cstat-no" title="statement not covered" >v</span>ar stat=_ref2[0];<span class="cstat-no" title="statement not covered" >v</span>ar option=_ref2[1];<span class="cstat-no" title="statement not covered" >i</span>f(!option){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(stat==='percentile'){<span class="cstat-no" title="statement not covered" >for(var percent of option){<span class="cstat-no" title="statement not covered" >var percentile=this.getApproximatePercentile(percent);<span class="cstat-no" title="statement not covered" >r</span>esults.set('pct_'+percentToString(percent),new tr.v.ScalarNumeric(this.unit,percentile));}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(stat==='nans'){<span class="cstat-no" title="statement not covered" >results.set('nans',new tr.v.ScalarNumeric(tr.b.Unit.byName.count_smallerIsBetter,this.numNans));}</span>else{<span class="cstat-no" title="statement not covered" >var statUnit=stat==='count'?tr.b.Unit.byName.count_smallerIsBetter:this.unit;<span class="cstat-no" title="statement not covered" >v</span>ar key=statNameToKey(stat);<span class="cstat-no" title="statement not covered" >v</span>ar statValue=this.running[key];<span class="cstat-no" title="statement not covered" >i</span>f(typeof statValue==='number'){<span class="cstat-no" title="statement not covered" >results.set(stat,new tr.v.ScalarNumeric(statUnit,statValue));}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn results;}</span>get sampleValues<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.sampleValues_;}</span>clone<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return Histogram.fromDict(this.asDict());}</span>cloneEmpty<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>var binBoundaries=HistogramBinBoundaries.fromDict(this.binBoundariesDict_);<span class="cstat-no" title="statement not covered" >r</span>eturn new Histogram(this.name,this.unit,binBoundaries);}</span>asDict<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>var dict={};<span class="cstat-no" title="statement not covered" >d</span>ict.binBoundaries=this.binBoundariesDict_;<span class="cstat-no" title="statement not covered" >d</span>ict.name=this.name;<span class="cstat-no" title="statement not covered" >d</span>ict.unit=this.unit.asJSON();<span class="cstat-no" title="statement not covered" >d</span>ict.guid=this.guid;<span class="cstat-no" title="statement not covered" >i</span>f(this.shortName){<span class="cstat-no" title="statement not covered" >dict.shortName=this.shortName;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.description){<span class="cstat-no" title="statement not covered" >dict.description=this.description;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.diagnostics.size){<span class="cstat-no" title="statement not covered" >dict.diagnostics=this.diagnostics.asDict();}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.maxNumSampleValues!==this.defaultMaxNumSampleValues_){<span class="cstat-no" title="statement not covered" >dict.maxNumSampleValues=this.maxNumSampleValues;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.numNans){<span class="cstat-no" title="statement not covered" >dict.numNans=this.numNans;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.nanDiagnosticMaps.length){<span class="cstat-no" title="statement not covered" >dict.nanDiagnostics=this.nanDiagnosticMaps.map(dm=&gt;<span class="cstat-no" title="statement not covered" >dm.asDict())</span>;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.underflowBin.count){<span class="cstat-no" title="statement not covered" >dict.underflowBin=this.underflowBin.asDict();}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.overflowBin.count){<span class="cstat-no" title="statement not covered" >dict.overflowBin=this.overflowBin.asDict();}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.numValues){<span class="cstat-no" title="statement not covered" >dict.sampleValues=this.sampleValues.slice();<span class="cstat-no" title="statement not covered" >d</span>ict.running=this.running.asDict();<span class="cstat-no" title="statement not covered" >d</span>ict.centralBins=this.centralBinsAsDict_();}<span class="cstat-no" title="statement not covered" ></span>v</span>ar summaryOptions={};<span class="cstat-no" title="statement not covered" >v</span>ar anyOverriddenSummaryOptions=false;<span class="cstat-no" title="statement not covered" >f</span>or(var _ref3 of this.summaryOptions){<span class="cstat-no" title="statement not covered" >var _ref4=_slicedToArray(_ref3,2);<span class="cstat-no" title="statement not covered" >v</span>ar name=_ref4[0];<span class="cstat-no" title="statement not covered" >v</span>ar option=_ref4[1];<span class="cstat-no" title="statement not covered" >i</span>f(name==='percentile'){<span class="cstat-no" title="statement not covered" >if(option.length===0){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>o</span>ption=option.slice();}</span>else <span class="cstat-no" title="statement not covered" >if(option===DEFAULT_SUMMARY_OPTIONS.get(name)){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>s</span></span>ummaryOptions[name]=option;<span class="cstat-no" title="statement not covered" >a</span>nyOverriddenSummaryOptions=true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(anyOverriddenSummaryOptions){<span class="cstat-no" title="statement not covered" >dict.summaryOptions=summaryOptions;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn dict;}</span>centralBinsAsDict_<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>var numCentralBins=this.centralBins.length;<span class="cstat-no" title="statement not covered" >v</span>ar emptyBins=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;numCentralBins;++i){<span class="cstat-no" title="statement not covered" >if(this.centralBins[i].count===0){<span class="cstat-no" title="statement not covered" >++emptyBins;}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(emptyBins===numCentralBins){<span class="cstat-no" title="statement not covered" >return undefined;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(emptyBins&gt;numCentralBins/2){<span class="cstat-no" title="statement not covered" >var centralBinsDict={};<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;numCentralBins;++i){<span class="cstat-no" title="statement not covered" >var bin=this.centralBins[i];<span class="cstat-no" title="statement not covered" >i</span>f(bin.count&gt;0){<span class="cstat-no" title="statement not covered" >centralBinsDict[i]=bin.asDict();}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn centralBinsDict;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar centralBinsArray=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;numCentralBins;++i){<span class="cstat-no" title="statement not covered" >centralBinsArray.push(this.centralBins[i].asDict());}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn centralBinsArray;}</span>get defaultMaxNumSampleValues_<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.allBins.length*10;}</span>}var HISTOGRAM_BIN_BOUNDARIES_CACHE=new Map();class HistogramBinBoundaries{static createLinear(min,max,numBins){return new HistogramBinBoundaries(min).addLinearBins(max,numBins);}static createExponential(min,max,numBins){return new HistogramBinBoundaries(min).addExponentialBins(max,numBins);}static createWithBoundaries<span class="fstat-no" title="function not covered" >(binBoundaries){<span class="cstat-no" title="statement not covered" ></span>var builder=new HistogramBinBoundaries(binBoundaries[0]);<span class="cstat-no" title="statement not covered" >f</span>or(var boundary of binBoundaries.slice(1))<span class="cstat-no" title="statement not covered" >builder.addBinBoundary(boundary);<span class="cstat-no" title="statement not covered" >r</span></span>eturn builder;}</span>static createFromSamples<span class="fstat-no" title="function not covered" >(samples){<span class="cstat-no" title="statement not covered" ></span>var range=new tr.b.Range();<span class="cstat-no" title="statement not covered" >f</span>or(var sample of samples)<span class="cstat-no" title="statement not covered" >if(!isNaN(Math.max(sample)))<span class="cstat-no" title="statement not covered" >range.addValue(sample);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(range.isEmpty)<span class="cstat-no" title="statement not covered" >range.addValue(1);<span class="cstat-no" title="statement not covered" >i</span></span>f(range.min===range.max)<span class="cstat-no" title="statement not covered" >range.addValue(range.min-1);<span class="cstat-no" title="statement not covered" >v</span></span>ar numBins=Math.ceil(Math.sqrt(samples.length));<span class="cstat-no" title="statement not covered" >v</span>ar builder=new HistogramBinBoundaries(range.min);<span class="cstat-no" title="statement not covered" >b</span>uilder.addLinearBins(range.max,numBins);<span class="cstat-no" title="statement not covered" >r</span>eturn builder;}</span>constructor(minBinBoundary){this.boundaries_=undefined;this.builder_=[minBinBoundary];this.range_=new tr.b.Range();this.range_.addValue(minBinBoundary);}get range(){return this.range_;}asDict<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.builder_.slice();}</span>static fromDict<span class="fstat-no" title="function not covered" >(dict){<span class="cstat-no" title="statement not covered" ></span>var cacheKey=JSON.stringify(dict);<span class="cstat-no" title="statement not covered" >i</span>f(HISTOGRAM_BIN_BOUNDARIES_CACHE.has(cacheKey)){<span class="cstat-no" title="statement not covered" >return HISTOGRAM_BIN_BOUNDARIES_CACHE.get(cacheKey);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar binBoundaries=new HistogramBinBoundaries(dict[0]);<span class="cstat-no" title="statement not covered" >f</span>or(var slice of dict.slice(1)){<span class="cstat-no" title="statement not covered" >if(!(slice instanceof Array)){<span class="cstat-no" title="statement not covered" >binBoundaries.addBinBoundary(slice);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(slice[0]){case HistogramBinBoundaries.SLICE_TYPE.LINEAR:<span class="cstat-no" title="statement not covered" >binBoundaries.addLinearBins(slice[1],slice[2]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase HistogramBinBoundaries.SLICE_TYPE.EXPONENTIAL:<span class="cstat-no" title="statement not covered" >binBoundaries.addExponentialBins(slice[1],slice[2]);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error('Unrecognized HistogramBinBoundaries slice type');}</span>}<span class="cstat-no" title="statement not covered" ></span>H</span>ISTOGRAM_BIN_BOUNDARIES_CACHE.set(cacheKey,binBoundaries);<span class="cstat-no" title="statement not covered" >r</span>eturn binBoundaries;}</span>*binRanges<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>if(this.boundaries_===undefined){<span class="cstat-no" title="statement not covered" >this.build_();}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=0;i&lt;this.boundaries_.length-1;++i){<span class="cstat-no" title="statement not covered" >yield tr.b.Range.fromExplicitRange(this.boundaries_[i],this.boundaries_[i+1]);}</span>}</span>build_<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>if(typeof this.builder_[0]!=='number'){<span class="cstat-no" title="statement not covered" >throw new Error('Invalid start of builder_');}<span class="cstat-no" title="statement not covered" ></span>t</span>his.boundaries_=[this.builder_[0]];<span class="cstat-no" title="statement not covered" >f</span>or(var slice of this.builder_.slice(1)){<span class="cstat-no" title="statement not covered" >if(!(slice instanceof Array)){<span class="cstat-no" title="statement not covered" >this.boundaries_.push(slice);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar nextMaxBinBoundary=slice[1];<span class="cstat-no" title="statement not covered" >v</span>ar binCount=slice[2];<span class="cstat-no" title="statement not covered" >v</span>ar curMaxBinBoundary=this.boundaries_[this.boundaries_.length-1];<span class="cstat-no" title="statement not covered" >s</span>witch(slice[0]){case HistogramBinBoundaries.SLICE_TYPE.LINEAR:<span class="cstat-no" title="statement not covered" >var binWidth=(nextMaxBinBoundary-curMaxBinBoundary)/binCount;<span class="cstat-no" title="statement not covered" >f</span>or(var i=1;i&lt;binCount;i++){<span class="cstat-no" title="statement not covered" >var boundary=curMaxBinBoundary+i*binWidth;<span class="cstat-no" title="statement not covered" >t</span>his.boundaries_.push(boundary);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase HistogramBinBoundaries.SLICE_TYPE.EXPONENTIAL:<span class="cstat-no" title="statement not covered" >var binExponentWidth=Math.log(nextMaxBinBoundary/curMaxBinBoundary)/binCount;<span class="cstat-no" title="statement not covered" >f</span>or(var i=1;i&lt;binCount;i++){<span class="cstat-no" title="statement not covered" >var boundary=curMaxBinBoundary*Math.exp(i*binExponentWidth);<span class="cstat-no" title="statement not covered" >t</span>his.boundaries_.push(boundary);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error('Unrecognized HistogramBinBoundaries slice type');}<span class="cstat-no" title="statement not covered" ></span>t</span>his.boundaries_.push(nextMaxBinBoundary);}</span>}</span>addBinBoundary(nextMaxBinBoundary){<span class="missing-if-branch" title="if path not taken" >I</span>if(nextMaxBinBoundary&lt;=this.range.max){<span class="cstat-no" title="statement not covered" >throw new Error('The added max bin boundary must be larger than '+'the current max boundary');}</span>this.boundaries_=undefined;this.builder_.push(nextMaxBinBoundary);this.range.addValue(nextMaxBinBoundary);return this;}addLinearBins(nextMaxBinBoundary,binCount){<span class="missing-if-branch" title="if path not taken" >I</span>if(binCount&lt;=0)<span class="cstat-no" title="statement not covered" >throw new Error('Bin count must be positive');<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(nextMaxBinBoundary&lt;=this.range.max){<span class="cstat-no" title="statement not covered" >throw new Error('The new max bin boundary must be greater than '+'the previous max bin boundary');}</span>this.boundaries_=undefined;this.builder_.push([HistogramBinBoundaries.SLICE_TYPE.LINEAR,nextMaxBinBoundary,binCount]);this.range.addValue(nextMaxBinBoundary);return this;}addExponentialBins(nextMaxBinBoundary,binCount){<span class="missing-if-branch" title="if path not taken" >I</span>if(binCount&lt;=0){<span class="cstat-no" title="statement not covered" >throw new Error('Bin count must be positive');}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(this.range.max&lt;=0){<span class="cstat-no" title="statement not covered" >throw new Error('Current max bin boundary must be positive');}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(this.range.max&gt;=nextMaxBinBoundary){<span class="cstat-no" title="statement not covered" >throw new Error('The last added max boundary must be greater than '+'the current max boundary boundary');}</span>this.boundaries_=undefined;this.builder_.push([HistogramBinBoundaries.SLICE_TYPE.EXPONENTIAL,nextMaxBinBoundary,binCount]);this.range.addValue(nextMaxBinBoundary);return this;}}HistogramBinBoundaries.SLICE_TYPE={LINEAR:0,EXPONENTIAL:1};DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.timeDurationInMs.unitName,HistogramBinBoundaries.createExponential(1e-3,1e6,1e2));DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.timeStampInMs.unitName,HistogramBinBoundaries.createLinear(0,1e10,1e3));DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.normalizedPercentage.unitName,HistogramBinBoundaries.createLinear(0,1.0,20));DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.sizeInBytes.unitName,HistogramBinBoundaries.createExponential(1,1e12,1e2));DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.energyInJoules.unitName,HistogramBinBoundaries.createExponential(1e-3,1e3,50));DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.powerInWatts.unitName,HistogramBinBoundaries.createExponential(1e-3,1,50));DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.unitlessNumber.unitName,HistogramBinBoundaries.createExponential(1e-3,1e3,50));DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.count.unitName,HistogramBinBoundaries.createExponential(1,1e3,20));return{Histogram:Histogram,HistogramBinBoundaries:HistogramBinBoundaries};});
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 14:21:24 GMT+0000 (UTC)</div>
</div>
</body>
</html>
