<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/extras/chrome/cc/input_latency_async_slice.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-lighthouse">npmtest-lighthouse (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/extras/chrome/cc/input_latency_async_slice.js</span></h1>
    <h2>
        
        Statements: <span class="metric">9.69% <small>(25 / 258)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0% <small>(0 / 151)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">6.06% <small>(2 / 33)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(1 / 1)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../../../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-lighthouse/node_modules/lighthouse/lighthouse-core/third_party/traceviewer-js/extras/chrome/cc/</a> &#187; input_latency_async_slice.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2</td><td class="line-coverage"><span class="cline-any cline-yes">29</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";require("../../../model/async_slice.js");require("../../../model/event_set.js");require("../../../model/helpers/chrome_model_helper.js");'use strict';global.tr.exportTo('tr.e.cc',function(){var AsyncSlice=tr.model.AsyncSlice;var EventSet=tr.model.EventSet;var UI_COMP_NAME='INPUT_EVENT_LATENCY_UI_COMPONENT';var ORIGINAL_COMP_NAME='INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT';var BEGIN_COMP_NAME='INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT';var END_COMP_NAME='INPUT_EVENT_LATENCY_TERMINATED_FRAME_SWAP_COMPONENT';var MAIN_RENDERER_THREAD_NAME='CrRendererMain';var COMPOSITOR_THREAD_NAME='Compositor';var POSTTASK_FLOW_EVENT='disabled-by-default-toplevel.flow';var IPC_FLOW_EVENT='disabled-by-default-ipc.flow';var INPUT_EVENT_TYPE_NAMES={CHAR:'Char',CLICK:'GestureClick',CONTEXT_MENU:'ContextMenu',FLING_CANCEL:'GestureFlingCancel',FLING_START:'GestureFlingStart',KEY_DOWN:'KeyDown',KEY_DOWN_RAW:'RawKeyDown',KEY_UP:'KeyUp',LATENCY_SCROLL_UPDATE:'ScrollUpdate',MOUSE_DOWN:'MouseDown',MOUSE_ENTER:'MouseEnter',MOUSE_LEAVE:'MouseLeave',MOUSE_MOVE:'MouseMove',MOUSE_UP:'MouseUp',MOUSE_WHEEL:'MouseWheel',PINCH_BEGIN:'GesturePinchBegin',PINCH_END:'GesturePinchEnd',PINCH_UPDATE:'GesturePinchUpdate',SCROLL_BEGIN:'GestureScrollBegin',SCROLL_END:'GestureScrollEnd',SCROLL_UPDATE:'GestureScrollUpdate',SCROLL_UPDATE_RENDERER:'ScrollUpdate',SHOW_PRESS:'GestureShowPress',TAP:'GestureTap',TAP_CANCEL:'GestureTapCancel',TAP_DOWN:'GestureTapDown',TOUCH_CANCEL:'TouchCancel',TOUCH_END:'TouchEnd',TOUCH_MOVE:'TouchMove',TOUCH_START:'TouchStart',UNKNOWN:'UNKNOWN'};<span class="fstat-no" title="function not covered" >function InputLatencyAsyncSlice(){<span class="cstat-no" title="statement not covered" ></span>AsyncSlice.apply(this,arguments);<span class="cstat-no" title="statement not covered" >t</span>his.associatedEvents_=new EventSet();<span class="cstat-no" title="statement not covered" >t</span>his.typeName_=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(!this.isLegacyEvent)<span class="cstat-no" title="statement not covered" >this.determineModernTypeName_();}</span></span>InputLatencyAsyncSlice.prototype={__proto__:AsyncSlice.prototype,get isLegacyEvent<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>return this.title==='InputLatency';}</span>,get typeName<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>if(!this.typeName_)<span class="cstat-no" title="statement not covered" >this.determineLegacyTypeName_();<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.typeName_;}</span>,checkTypeName_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(!this.typeName_)<span class="cstat-no" title="statement not covered" >throw'Unable to determine typeName';<span class="cstat-no" title="statement not covered" >v</span></span>ar found=false;<span class="cstat-no" title="statement not covered" >f</span>or(var typeName in INPUT_EVENT_TYPE_NAMES){<span class="cstat-no" title="statement not covered" >if(this.typeName===INPUT_EVENT_TYPE_NAMES[typeName]){<span class="cstat-no" title="statement not covered" >found=true;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!found)<span class="cstat-no" title="statement not covered" >this.typeName_=INPUT_EVENT_TYPE_NAMES.UNKNOWN;}</span></span>,determineModernTypeName_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var lastColonIndex=this.title.lastIndexOf(':');<span class="cstat-no" title="statement not covered" >i</span>f(lastColonIndex&lt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar characterAfterLastColonIndex=lastColonIndex+1;<span class="cstat-no" title="statement not covered" >t</span>his.typeName_=this.title.slice(characterAfterLastColonIndex);<span class="cstat-no" title="statement not covered" >t</span>his.checkTypeName_();}</span>,determineLegacyTypeName_:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>for(var subSlice of this.enumerateAllDescendents()){<span class="cstat-no" title="statement not covered" >var subSliceIsAInputLatencyAsyncSlice=subSlice instanceof InputLatencyAsyncSlice;<span class="cstat-no" title="statement not covered" >i</span>f(!subSliceIsAInputLatencyAsyncSlice)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(!subSlice.typeName)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.typeName_&amp;&amp;subSlice.typeName_){<span class="cstat-no" title="statement not covered" >var subSliceHasDifferentTypeName=this.typeName_!==subSlice.typeName_;<span class="cstat-no" title="statement not covered" >i</span>f(subSliceHasDifferentTypeName){<span class="cstat-no" title="statement not covered" >throw'InputLatencyAsyncSlice.determineLegacyTypeName_() '+' found multiple typeNames';}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.typeName_=subSlice.typeName_;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.typeName_)<span class="cstat-no" title="statement not covered" >throw'InputLatencyAsyncSlice.determineLegacyTypeName_() failed';<span class="cstat-no" title="statement not covered" >t</span></span>his.checkTypeName_();}</span>,getRendererHelper:<span class="fstat-no" title="function not covered" >function(sourceSlices){<span class="cstat-no" title="statement not covered" ></span>var traceModel=this.startThread.parent.model;<span class="cstat-no" title="statement not covered" >v</span>ar modelHelper=traceModel.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);<span class="cstat-no" title="statement not covered" >i</span>f(!modelHelper)<span class="cstat-no" title="statement not covered" >return undefined;<span class="cstat-no" title="statement not covered" >v</span></span>ar mainThread=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar compositorThread=undefined;<span class="cstat-no" title="statement not covered" >f</span>or(var i in sourceSlices){<span class="cstat-no" title="statement not covered" >if(sourceSlices[i].parentContainer.name===MAIN_RENDERER_THREAD_NAME)<span class="cstat-no" title="statement not covered" >mainThread=sourceSlices[i].parentContainer;e</span>lse <span class="cstat-no" title="statement not covered" >if(sourceSlices[i].parentContainer.name===COMPOSITOR_THREAD_NAME)<span class="cstat-no" title="statement not covered" >compositorThread=sourceSlices[i].parentContainer;<span class="cstat-no" title="statement not covered" >i</span></span></span>f(mainThread&amp;&amp;compositorThread)<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span></span>v</span>ar rendererHelpers=modelHelper.rendererHelpers;<span class="cstat-no" title="statement not covered" >v</span>ar pids=Object.keys(rendererHelpers);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;pids.length;i++){<span class="cstat-no" title="statement not covered" >var pid=pids[i];<span class="cstat-no" title="statement not covered" >v</span>ar rendererHelper=rendererHelpers[pid];<span class="cstat-no" title="statement not covered" >i</span>f(rendererHelper.mainThread===mainThread||rendererHelper.compositorThread===compositorThread)<span class="cstat-no" title="statement not covered" >return rendererHelper;}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn undefined;}</span>,addEntireSliceHierarchy:<span class="fstat-no" title="function not covered" >function(slice){<span class="cstat-no" title="statement not covered" ></span>this.associatedEvents_.push(slice);<span class="cstat-no" title="statement not covered" >s</span>lice.iterateAllSubsequentSlices(<span class="fstat-no" title="function not covered" >function(subsequentSlice){<span class="cstat-no" title="statement not covered" ></span>this.associatedEvents_.push(subsequentSlice);}</span>,this);}</span>,addDirectlyAssociatedEvents:<span class="fstat-no" title="function not covered" >function(flowEvents){<span class="cstat-no" title="statement not covered" ></span>var slices=[];<span class="cstat-no" title="statement not covered" >f</span>lowEvents.forEach(<span class="fstat-no" title="function not covered" >function(flowEvent){<span class="cstat-no" title="statement not covered" ></span>this.associatedEvents_.push(flowEvent);<span class="cstat-no" title="statement not covered" >v</span>ar newSource=flowEvent.startSlice.mostTopLevelSlice;<span class="cstat-no" title="statement not covered" >i</span>f(slices.indexOf(newSource)===-1)<span class="cstat-no" title="statement not covered" >slices.push(newSource);}</span></span>,this);<span class="cstat-no" title="statement not covered" >v</span>ar lastFlowEvent=flowEvents[flowEvents.length-1];<span class="cstat-no" title="statement not covered" >v</span>ar lastSource=lastFlowEvent.endSlice.mostTopLevelSlice;<span class="cstat-no" title="statement not covered" >i</span>f(slices.indexOf(lastSource)===-1)<span class="cstat-no" title="statement not covered" >slices.push(lastSource);<span class="cstat-no" title="statement not covered" >r</span></span>eturn slices;}</span>,addScrollUpdateEvents:<span class="fstat-no" title="function not covered" >function(rendererHelper){<span class="cstat-no" title="statement not covered" ></span>if(!rendererHelper||!rendererHelper.compositorThread)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar compositorThread=rendererHelper.compositorThread;<span class="cstat-no" title="statement not covered" >v</span>ar gestureScrollUpdateStart=this.start;<span class="cstat-no" title="statement not covered" >v</span>ar gestureScrollUpdateEnd=this.end;<span class="cstat-no" title="statement not covered" >v</span>ar allCompositorAsyncSlices=compositorThread.asyncSliceGroup.slices;<span class="cstat-no" title="statement not covered" >f</span>or(var i in allCompositorAsyncSlices){<span class="cstat-no" title="statement not covered" >var slice=allCompositorAsyncSlices[i];<span class="cstat-no" title="statement not covered" >i</span>f(slice.title!=='Latency::ScrollUpdate')<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar parentId=slice.args.data.INPUT_EVENT_LATENCY_FORWARD_SCROLL_UPDATE_TO_MAIN_COMPONENT.sequence_number;<span class="cstat-no" title="statement not covered" >i</span>f(parentId===undefined){<span class="cstat-no" title="statement not covered" >if(slice.start&lt;gestureScrollUpdateStart||slice.start&gt;=gestureScrollUpdateEnd)<span class="cstat-no" title="statement not covered" >continue;}</span></span>else{<span class="cstat-no" title="statement not covered" >if(parseInt(parentId)!==parseInt(this.id))<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span></span>s</span>lice.associatedEvents.forEach(<span class="fstat-no" title="function not covered" >function(event){<span class="cstat-no" title="statement not covered" ></span>this.associatedEvents_.push(event);}</span>,this);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>,belongToOtherInputs:<span class="fstat-no" title="function not covered" >function(slice,flowEvents){<span class="cstat-no" title="statement not covered" ></span>var fromOtherInputs=false;<span class="cstat-no" title="statement not covered" >s</span>lice.iterateEntireHierarchy(<span class="fstat-no" title="function not covered" >function(subsequentSlice){<span class="cstat-no" title="statement not covered" ></span>if(fromOtherInputs)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span></span>ubsequentSlice.inFlowEvents.forEach(<span class="fstat-no" title="function not covered" >function(inflow){<span class="cstat-no" title="statement not covered" ></span>if(fromOtherInputs)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(inflow.category.indexOf('input')&gt;-1){<span class="cstat-no" title="statement not covered" >if(flowEvents.indexOf(inflow)===-1)<span class="cstat-no" title="statement not covered" >fromOtherInputs=true;}</span></span>}</span>,this);}</span>,this);<span class="cstat-no" title="statement not covered" >r</span>eturn fromOtherInputs;}</span>,triggerOtherInputs:<span class="fstat-no" title="function not covered" >function(event,flowEvents){<span class="cstat-no" title="statement not covered" ></span>if(event.outFlowEvents===undefined||event.outFlowEvents.length===0)<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >v</span></span>ar flow=event.outFlowEvents[0];<span class="cstat-no" title="statement not covered" >i</span>f(flow.category!==POSTTASK_FLOW_EVENT||!flow.endSlice)<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >v</span></span>ar endSlice=flow.endSlice;<span class="cstat-no" title="statement not covered" >i</span>f(this.belongToOtherInputs(endSlice.mostTopLevelSlice,flowEvents))<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >r</span></span>eturn false;}</span>,followSubsequentSlices:<span class="fstat-no" title="function not covered" >function(event,queue,visited,flowEvents){<span class="cstat-no" title="statement not covered" ></span>var stopFollowing=false;<span class="cstat-no" title="statement not covered" >v</span>ar inputAck=false;<span class="cstat-no" title="statement not covered" >e</span>vent.iterateAllSubsequentSlices(<span class="fstat-no" title="function not covered" >function(slice){<span class="cstat-no" title="statement not covered" ></span>if(stopFollowing)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(slice.title==='TaskQueueManager::RunTask')<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(slice.title==='ThreadProxy::ScheduledActionSendBeginMainFrame')<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(slice.title==='Scheduler::ScheduleBeginImplFrameDeadline'){<span class="cstat-no" title="statement not covered" >if(this.triggerOtherInputs(slice,flowEvents))<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(slice.title==='CompositorImpl::PostComposite'){<span class="cstat-no" title="statement not covered" >if(this.triggerOtherInputs(slice,flowEvents))<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(slice.title==='InputRouterImpl::ProcessInputEventAck')<span class="cstat-no" title="statement not covered" >inputAck=true;<span class="cstat-no" title="statement not covered" >i</span></span>f(inputAck&amp;&amp;slice.title==='InputRouterImpl::FilterAndSendWebInputEvent')<span class="cstat-no" title="statement not covered" >stopFollowing=true;<span class="cstat-no" title="statement not covered" >t</span></span>his.followCurrentSlice(slice,queue,visited);}</span>,this);}</span>,followCurrentSlice:<span class="fstat-no" title="function not covered" >function(event,queue,visited){<span class="cstat-no" title="statement not covered" ></span>event.outFlowEvents.forEach(<span class="fstat-no" title="function not covered" >function(outflow){<span class="cstat-no" title="statement not covered" ></span>if((outflow.category===POSTTASK_FLOW_EVENT||outflow.category===IPC_FLOW_EVENT)&amp;&amp;outflow.endSlice){<span class="cstat-no" title="statement not covered" >this.associatedEvents_.push(outflow);<span class="cstat-no" title="statement not covered" >v</span>ar nextEvent=outflow.endSlice.mostTopLevelSlice;<span class="cstat-no" title="statement not covered" >i</span>f(!visited.contains(nextEvent)){<span class="cstat-no" title="statement not covered" >visited.push(nextEvent);<span class="cstat-no" title="statement not covered" >q</span>ueue.push(nextEvent);}</span>}</span>}</span>,this);}</span>,backtraceFromDraw:<span class="fstat-no" title="function not covered" >function(beginImplFrame,visited){<span class="cstat-no" title="statement not covered" ></span>var pendingEventQueue=[];<span class="cstat-no" title="statement not covered" >p</span>endingEventQueue.push(beginImplFrame.mostTopLevelSlice);<span class="cstat-no" title="statement not covered" >w</span>hile(pendingEventQueue.length!==0){<span class="cstat-no" title="statement not covered" >var event=pendingEventQueue.pop();<span class="cstat-no" title="statement not covered" >t</span>his.addEntireSliceHierarchy(event);<span class="cstat-no" title="statement not covered" >e</span>vent.inFlowEvents.forEach(<span class="fstat-no" title="function not covered" >function(inflow){<span class="cstat-no" title="statement not covered" ></span>if(inflow.category===POSTTASK_FLOW_EVENT&amp;&amp;inflow.startSlice){<span class="cstat-no" title="statement not covered" >var nextEvent=inflow.startSlice.mostTopLevelSlice;<span class="cstat-no" title="statement not covered" >i</span>f(!visited.contains(nextEvent)){<span class="cstat-no" title="statement not covered" >visited.push(nextEvent);<span class="cstat-no" title="statement not covered" >p</span>endingEventQueue.push(nextEvent);}</span>}</span>}</span>,this);}</span>}</span>,sortRasterizerSlices:<span class="fstat-no" title="function not covered" >function(rasterWorkerThreads,sortedRasterizerSlices){<span class="cstat-no" title="statement not covered" ></span>rasterWorkerThreads.forEach(<span class="fstat-no" title="function not covered" >function(rasterizer){<span class="cstat-no" title="statement not covered" ></span>Array.prototype.push.apply(sortedRasterizerSlices,rasterizer.sliceGroup.slices);}</span>,this);<span class="cstat-no" title="statement not covered" >s</span>ortedRasterizerSlices.sort(<span class="fstat-no" title="function not covered" >function(a,b){<span class="cstat-no" title="statement not covered" ></span>if(a.start!==b.start)<span class="cstat-no" title="statement not covered" >return a.start-b.start;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a.guid-b.guid;}</span>);}</span>,addRasterizationEvents:<span class="fstat-no" title="function not covered" >function(prepareTiles,rendererHelper,visited,flowEvents,sortedRasterizerSlices){<span class="cstat-no" title="statement not covered" ></span>if(!prepareTiles.args.prepare_tiles_id)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!rendererHelper||!rendererHelper.rasterWorkerThreads)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar rasterWorkerThreads=rendererHelper.rasterWorkerThreads;<span class="cstat-no" title="statement not covered" >v</span>ar prepareTileId=prepareTiles.args.prepare_tiles_id;<span class="cstat-no" title="statement not covered" >v</span>ar pendingEventQueue=[];<span class="cstat-no" title="statement not covered" >i</span>f(sortedRasterizerSlices.length===0)<span class="cstat-no" title="statement not covered" >this.sortRasterizerSlices(rasterWorkerThreads,sortedRasterizerSlices);<span class="cstat-no" title="statement not covered" >v</span></span>ar numFinishedTasks=0;<span class="cstat-no" title="statement not covered" >v</span>ar RASTER_TASK_TITLE='RasterizerTaskImpl::RunOnWorkerThread';<span class="cstat-no" title="statement not covered" >v</span>ar IMAGEDECODE_TASK_TITLE='ImageDecodeTaskImpl::RunOnWorkerThread';<span class="cstat-no" title="statement not covered" >v</span>ar FINISHED_TASK_TITLE='TaskSetFinishedTaskImpl::RunOnWorkerThread';<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;sortedRasterizerSlices.length;i++){<span class="cstat-no" title="statement not covered" >var task=sortedRasterizerSlices[i];<span class="cstat-no" title="statement not covered" >i</span>f(task.title===RASTER_TASK_TITLE||task.title===IMAGEDECODE_TASK_TITLE){<span class="cstat-no" title="statement not covered" >if(task.args.source_prepare_tiles_id===prepareTileId)<span class="cstat-no" title="statement not covered" >this.addEntireSliceHierarchy(task.mostTopLevelSlice);}</span></span>else <span class="cstat-no" title="statement not covered" >if(task.title===FINISHED_TASK_TITLE){<span class="cstat-no" title="statement not covered" >if(task.start&gt;prepareTiles.start){<span class="cstat-no" title="statement not covered" >pendingEventQueue.push(task.mostTopLevelSlice);<span class="cstat-no" title="statement not covered" >i</span>f(++numFinishedTasks===3)<span class="cstat-no" title="statement not covered" >break;}</span></span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>w</span>hile(pendingEventQueue.length!=0){<span class="cstat-no" title="statement not covered" >var event=pendingEventQueue.pop();<span class="cstat-no" title="statement not covered" >t</span>his.addEntireSliceHierarchy(event);<span class="cstat-no" title="statement not covered" >t</span>his.followSubsequentSlices(event,pendingEventQueue,visited,flowEvents);}</span>}</span>,addOtherCausallyRelatedEvents:<span class="fstat-no" title="function not covered" >function(rendererHelper,sourceSlices,flowEvents,sortedRasterizerSlices){<span class="cstat-no" title="statement not covered" ></span>var pendingEventQueue=[];<span class="cstat-no" title="statement not covered" >v</span>ar visitedEvents=new EventSet();<span class="cstat-no" title="statement not covered" >v</span>ar beginImplFrame=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar prepareTiles=undefined;<span class="cstat-no" title="statement not covered" >v</span>ar sortedRasterizerSlices=[];<span class="cstat-no" title="statement not covered" >s</span>ourceSlices.forEach(<span class="fstat-no" title="function not covered" >function(sourceSlice){<span class="cstat-no" title="statement not covered" ></span>if(!visitedEvents.contains(sourceSlice)){<span class="cstat-no" title="statement not covered" >visitedEvents.push(sourceSlice);<span class="cstat-no" title="statement not covered" >p</span>endingEventQueue.push(sourceSlice);}</span>}</span>,this);<span class="cstat-no" title="statement not covered" >w</span>hile(pendingEventQueue.length!=0){<span class="cstat-no" title="statement not covered" >var event=pendingEventQueue.pop();<span class="cstat-no" title="statement not covered" >t</span>his.addEntireSliceHierarchy(event);<span class="cstat-no" title="statement not covered" >t</span>his.followCurrentSlice(event,pendingEventQueue,visitedEvents);<span class="cstat-no" title="statement not covered" >t</span>his.followSubsequentSlices(event,pendingEventQueue,visitedEvents,flowEvents);<span class="cstat-no" title="statement not covered" >v</span>ar COMPOSITOR_PREPARE_TILES='TileManager::PrepareTiles';<span class="cstat-no" title="statement not covered" >p</span>repareTiles=event.findDescendentSlice(COMPOSITOR_PREPARE_TILES);<span class="cstat-no" title="statement not covered" >i</span>f(prepareTiles)<span class="cstat-no" title="statement not covered" >this.addRasterizationEvents(prepareTiles,rendererHelper,visitedEvents,flowEvents,sortedRasterizerSlices);<span class="cstat-no" title="statement not covered" >v</span></span>ar COMPOSITOR_ON_BIFD='Scheduler::OnBeginImplFrameDeadline';<span class="cstat-no" title="statement not covered" >b</span>eginImplFrame=event.findDescendentSlice(COMPOSITOR_ON_BIFD);<span class="cstat-no" title="statement not covered" >i</span>f(beginImplFrame)<span class="cstat-no" title="statement not covered" >this.backtraceFromDraw(beginImplFrame,visitedEvents);}<span class="cstat-no" title="statement not covered" ></span></span>v</span>ar INPUT_GSU='InputLatency::GestureScrollUpdate';<span class="cstat-no" title="statement not covered" >i</span>f(this.title===INPUT_GSU)<span class="cstat-no" title="statement not covered" >this.addScrollUpdateEvents(rendererHelper);}</span></span>,get associatedEvents<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>if(this.associatedEvents_.length!==0)<span class="cstat-no" title="statement not covered" >return this.associatedEvents_;<span class="cstat-no" title="statement not covered" >v</span></span>ar modelIndices=this.startThread.parent.model.modelIndices;<span class="cstat-no" title="statement not covered" >v</span>ar flowEvents=modelIndices.getFlowEventsWithId(this.id);<span class="cstat-no" title="statement not covered" >i</span>f(flowEvents.length===0)<span class="cstat-no" title="statement not covered" >return this.associatedEvents_;<span class="cstat-no" title="statement not covered" >v</span></span>ar sourceSlices=this.addDirectlyAssociatedEvents(flowEvents);<span class="cstat-no" title="statement not covered" >v</span>ar rendererHelper=this.getRendererHelper(sourceSlices);<span class="cstat-no" title="statement not covered" >t</span>his.addOtherCausallyRelatedEvents(rendererHelper,sourceSlices,flowEvents);<span class="cstat-no" title="statement not covered" >r</span>eturn this.associatedEvents_;}</span>,get inputLatency<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>if(!('data'in this.args))<span class="cstat-no" title="statement not covered" >return undefined;<span class="cstat-no" title="statement not covered" >v</span></span>ar data=this.args.data;<span class="cstat-no" title="statement not covered" >i</span>f(!(END_COMP_NAME in data))<span class="cstat-no" title="statement not covered" >return undefined;<span class="cstat-no" title="statement not covered" >v</span></span>ar latency=0;<span class="cstat-no" title="statement not covered" >v</span>ar endTime=data[END_COMP_NAME].time;<span class="cstat-no" title="statement not covered" >i</span>f(ORIGINAL_COMP_NAME in data){<span class="cstat-no" title="statement not covered" >latency=endTime-data[ORIGINAL_COMP_NAME].time;}</span>else <span class="cstat-no" title="statement not covered" >if(UI_COMP_NAME in data){<span class="cstat-no" title="statement not covered" >latency=endTime-data[UI_COMP_NAME].time;}</span>else <span class="cstat-no" title="statement not covered" >if(BEGIN_COMP_NAME in data){<span class="cstat-no" title="statement not covered" >latency=endTime-data[BEGIN_COMP_NAME].time;}</span>else{<span class="cstat-no" title="statement not covered" >throw new Error('No valid begin latency component');}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn latency;}</span>};var eventTypeNames=['Char','ContextMenu','GestureClick','GestureFlingCancel','GestureFlingStart','GestureScrollBegin','GestureScrollEnd','GestureScrollUpdate','GestureShowPress','GestureTap','GestureTapCancel','GestureTapDown','GesturePinchBegin','GesturePinchEnd','GesturePinchUpdate','KeyDown','KeyUp','MouseDown','MouseEnter','MouseLeave','MouseMove','MouseUp','MouseWheel','RawKeyDown','ScrollUpdate','TouchCancel','TouchEnd','TouchMove','TouchStart'];var allTypeNames=['InputLatency'];eventTypeNames.forEach(function(eventTypeName){allTypeNames.push('InputLatency:'+eventTypeName);allTypeNames.push('InputLatency::'+eventTypeName);});AsyncSlice.subTypes.register(InputLatencyAsyncSlice,{typeNames:allTypeNames,categoryParts:['latencyInfo']});return{InputLatencyAsyncSlice:InputLatencyAsyncSlice,INPUT_EVENT_TYPE_NAMES:INPUT_EVENT_TYPE_NAMES};});
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 14:22:44 GMT+0000 (UTC)</div>
</div>
</body>
</html>
